
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>观察 记录 思考</title>
  <meta name="author" content="Cando">

  
  <meta name="description" content="睡眠很重要 你在清醒中学习的时候你的大脑会分泌出毒素。那你的大脑是如何排出这些毒素的呢？答案就是：睡觉。 当你睡觉的时候，你的脑细胞就会收缩 Turns out that when you sleep, your brain cells shrink. 因此细胞之间的空隙就会增大。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://candochen.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="观察 记录 思考" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <!--
-->
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">观察 记录 思考</a></h1>
  
    <h2>关于计算机、数学、英语和历史的点滴</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:candochen.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/01/learning-how-to-learn-4/">如何学习 (4)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-09-01T09:26:39+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>9:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">睡眠很重要</h2>

<p>你在清醒中学习的时候你的大脑会分泌出毒素。那你的大脑是如何排出这些毒素的呢？答案就是：睡觉。</p>

<p>当你睡觉的时候，你的脑细胞就会收缩</p>

<blockquote>
  <p>Turns out that when you sleep, your brain cells shrink.</p>
</blockquote>

<p>因此细胞之间的空隙就会增大。这就像是打开了一个水龙头，流体流过大脑细胞间隙的时候，也就把毒素给排出去了。</p>

<blockquote>
  <p>Fluid can flow past these cells and wash the toxins out.</p>
</blockquote>

<p>有时候你可能会觉得睡觉挺浪费时间的，但是这是有回报的：你的大脑更加干净和健康。</p>

<p>实际上，缺乏睡眠不仅对你的大脑健康造成损害，而且对你的健康还造成影响，比如会导致心脏病，头疼，抑郁，等等。</p>

<p>当然过多的睡眠跟过少的睡眠是一样的。</p>

<p>充足的睡眠除了对你的健康有益外，对你的学习也大有裨益。</p>

<blockquote>
  <p>Sleep has also been shown to make a remarkable difference in your ability to figure out difficult problems and to understand what you’re trying to learn.</p>
</blockquote>

<p>在你睡觉的时候，负责你意识清醒的大脑前额皮质会松弛下来，这给激活大脑其他的区域创造了机会。于是这些在你睡觉的时候依然工作的大脑各个区域组成解决你学习任务的神经系统。</p>

<p>在你打盹或者睡觉之前，如果你集中精力思考一个问题，你可能会梦到你所思考的问题。而梦到你所思考的问题还会增加你理解问题的能力。</p>

<p>所以充足的睡眠是你学习的一部分，不要再觉得睡觉浪费时间了。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/scala-2/">Scala 点滴 (2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T11:20:58+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>11:20 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="scala">Scala函数之初体验</h2>

<p>下面这个例子是Scala发明者Martin Odersky在Coursera上授课用的例子，这个例子在SICP(Structure and Interpretation of Computer Programs, 计算机程序的构造和解释)一书中也有。我这里重述这个例子的原因是这个例子即包含数学思想又包含Scala语法，它即实用又有趣。</p>

<p>它就是，</p>

<h3 id="sqrt2">通过牛顿法求$\sqrt{2}$的近似值</h3>

<p>从这篇维基百科<a href="http://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法介绍</a> 我们可以知道，牛顿法是一种迭代方法。所谓迭代的意思是上一次计算的结果都对本次计算起作用，换句话说，上次计算得出的结果可以作为本次计算的输入。</p>

<p>本文主要讲述如果用Scala实现牛顿法，所以牛顿法的分析过程就此略过，而直接给出公式：</p>

<script type="math/tex; mode=display">x_{n+1} = x_n - \frac{f(x_n)}{f'(x_{n})}</script>

<p>$\sqrt{2}$就是$f(x) = x^2 - 2 = 0$的根，根据上面的公式通过求得</p>

<script type="math/tex; mode=display">x_{n+1} = \frac{x_n + \frac{2}{x_n}}{2}</script>

<p>现在只要给出一个初始值$x_0$就可以通过上面的迭代公式求出结果。因为$f(x) = x^2 - 2 = 0$，所以$x^2=2$，易知1&lt;x&lt;2。因此，我们可以给出一个初始值$x_0 = 1 $ 。</p>

<p>一切准备工作就绪，我可以编程了…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">def isGoodEnough(guess: Double) = 
</span><span class="line">	abs(guess * guess - 2) &lt; 0.000001
</span><span class="line">
</span><span class="line">//这个就是迭代公式
</span><span class="line">def improve(guess: Double) = (guess + 2/guess) / 2
</span><span class="line">
</span><span class="line">//迭代函数,迭代函数必须有返回值类型
</span><span class="line">def iter(guess: Double):Double = {
</span><span class="line">	if (isGoodEnough(guess)) guess
</span><span class="line">	else iter(improve(guess))
</span><span class="line">}
</span><span class="line">
</span><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt2 = iter(1)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>学过编程的人都会觉得上面的程序好傻。首先，这个sqrt2只能够求$\sqrt{2}$的值，它不能求$\sqrt{3} , \sqrt{5} …$, 其次isGoodEnough函数的精度不能写死了，总之不够灵活(flexible)。</p>

<p>所以，我进行第一次重构…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>第一次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">val precision = 0.000001
</span><span class="line">
</span><span class="line">//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">def isGoodEnough(guess: Double, x: Double) = 
</span><span class="line">	abs(guess * guess - x) &lt; precision
</span><span class="line">
</span><span class="line">//这个就是迭代公式
</span><span class="line">def improve(guess: Double, x: Double) = (guess + x/guess) / 2
</span><span class="line">
</span><span class="line">//迭代函数,迭代函数必须有返回值类型
</span><span class="line">def iter(guess: Double, x: Double):Double = {
</span><span class="line">	if (isGoodEnough(guess, x)) guess
</span><span class="line">	else iter(improve(guess, x), x)
</span><span class="line">}
</span><span class="line">
</span><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt(x: Double) = iter(1, x)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>经过一次重构，程序比第一次好些了，但是还有个问题：因为isGoodEnough, improve, iter这些函数都是sqrt函数计算的一部分，能不能把它们封装到函数sqrt里面呢？ 答案是可以的，这也正是Scala的一个优点（相对于Java）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>第二次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt(x: Double)  = {
</span><span class="line">	val precision = 0.000001
</span><span class="line">	
</span><span class="line">	//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">	def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">	//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">	def isGoodEnough(guess: Double, x: Double) = 
</span><span class="line">		abs(guess * guess - x) &lt; precision
</span><span class="line">
</span><span class="line">	//这个就是迭代公式
</span><span class="line">	def improve(guess: Double, x: Double) = (guess + x/guess) / 2
</span><span class="line">
</span><span class="line">	//迭代函数,迭代函数必须有返回值类型
</span><span class="line">	def iter(guess: Double, x: Double):Double = {
</span><span class="line">		if (isGoodEnough(guess, x)) guess
</span><span class="line">		else iter(improve(guess, x), x)
</span><span class="line">	}	
</span><span class="line">	
</span><span class="line">	iter(1, x)
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>至此，假如你刚学Scala，我相信这个例子能给一些Scala函数的初步印象，比如函数的形式，再比如函数里面嵌套函数，但这绝对不是Scala函数的全貌。要知道函数在Scala里可是first-class citizen (头等公民)，关于这点我在后续文章里会有分享。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/scala-1/">Scala 点滴 (1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T11:06:48+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>11:06 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在Coursera上学习Scala编程有两个月了， Scala的基础课程即将结束。在新的课程《响应式编程》开始之前，我想总结一下。</p>

<h2 id="section">编程范式</h2>

<p>如果我们把现在的编程范式做下分类，我们可以分成3类：</p>

<blockquote>
  <ol>
    <li>指令编程范式</li>
    <li>函数编程范式</li>
    <li>逻辑编程范式</li>
  </ol>
</blockquote>

<p>而以上每种编程范式都与面向对象编程范式正交，意思是说指令型编程语言可以拥有面向对象特征，同理其他两种编程范式都可以拥有面向对象的特征。</p>

<p>所谓指令型编程语言范式是从冯. 诺依曼的计算机模型引申而来的，它的特点正如冯.诺依曼模型一样，运行时通过总线把它把指令和数据从内存加载到CPU，然后把结果又送回去。
更具体地说，指令编程范式对于于冯.诺依曼计算机模型有一种对应关系，</p>

<blockquote>
  <ol>
    <li>变量 相对于 内存单元</li>
    <li>释放变量  相对于 load 指令</li>
    <li>变量赋值  相对于 store 指令  </li>
    <li>分支控制  相对于 jump 指令</li>
  </ol>
</blockquote>

<p>在严格定义下，函数式编程范式则有以下特点</p>

<blockquote>
  <ol>
    <li>没有变量，也就没有对变量赋值</li>
    <li>没有指令编程范式的控制结构，例如while，loop等等</li>
    <li>函数是函数式编程范式里的头等公民，这意味着函数，就像普通值一样，可以在任何地方定义，包括在其他函数里面；此外，函数也像普通值一样，可以作为参数传到其他函数里，或作为结果返回，当然我们也可以对函数定义一下操作符用于把函数组合起来。</li>
  </ol>
</blockquote>

<p>假如我宽泛地给函数式编程范式给个定义，我们可以说，函数式编程范式主要是一种关注函数的编程范式。</p>

<p>至于逻辑编程范式，由于Martin Ordersky并没有给出解释，所以这里也略过。</p>

<p>在市面上的流行语言中，如果根据以上编程范式分类，函数式编程语言看起来应该像这样子</p>

<ol>
  <li>
    <p>严格定义下的函数式编程语言</p>

    <blockquote>
      <p>Pure Lisp, XSLT, XPath, XQuery, FP
 Haskell (without I/O Monad or UnsafePerformIO)</p>
    </blockquote>
  </li>
  <li>
    <p>广义定义下的函数式编程语言</p>

    <blockquote>
      <p>Lisp, Scheme, Racket, Clojure
SML, Ocaml, F#
Haskell (full language)
Scala
Smalltalk, Ruby (!)</p>
    </blockquote>
  </li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/learning-how-to-learn-3/">如何学习 (3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T10:32:53+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>10:32 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="long-term-memory-working-memory-">Long term memory Working Memory 长期记忆和工作记忆</h2>
<p>假如你要回忆童年往事或者数学公式，你用的是人脑中负责长期记忆的long term memory；假如你想把其中一些概念联系起来解决某些问题，你要的是working memory。
你有时候会把一些记忆从long term memory取出，然后放到working memory里，这时候long term memory就和working memory发生了联系。（我觉得，就这working memory 和 long term memory的关系来说，很像计算机中内存和硬盘的关系–当信息需要长期存储的时候它被放到硬盘中；当它需要被处理的时候，把它载到内存中处理。）</p>

<p>表面上来看，working memory就像一个黑盒子，但是这个盒子里面的东西是很容易模糊的，比如你要写下一串数字，你需要重复好几次才能把它记得，然后才能写下来。</p>

<p>当你学习新事物的时候，你使用working memory。</p>

<p>Long term memory非常重要，你的解决问题的技巧等等都存放在long term memory里，于是你需要往long term memory里存放信息。</p>

<p>当你第一次把某信息放入long term memory，你起码需要重复“访问”它几次，这样你才能增加下次找到它的几率。同时不同的item在long term memory里还可能会相互覆盖，这时候你需要更多的练习才可能从这相互覆盖的区域找到你想要的东西。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/29/learning-how-to-learn-2/">如何学习 (2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-29T20:23:11+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>8:23 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1 id="practice-makes-permanent">Practice makes permanent</h1>

<p>Bard 老师从16岁才开始真正地学习数学，在那之前她非常害怕和痛恨学习数学和科学。她没想到她后来回从事工程(engineering)的工作。刚开始的时候，她觉得数学太难了，在她看来数学对其他同学来说是那么容易–他们学得又快又准。在学习过程中，她有时候会放下学习，到外面的世界去逛逛，回来之后再继续学。她说，她不是自然就学会数学的，而是一步一步、循序渐进地学习得来的。</p>

<p>数学是抽象的，它不容易掌握，不像具体的事物，比如一头奶牛，你知道cow是奶牛的意思，你可以对着奶牛指着它，看着它学习cow。 但是数学通常情况下没有类似的东西让你比较，让你联系。当然你可以说，类似“爱”，“希望”这些词也是抽象的，但是通常这些词可以从人的情感中找到联系，但是数学概念不行。</p>

<p>正是因为数学是抽象的，我们需要不停地练习以强化数学思想。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/29/learning-how-to-learn-1/">如何学习 (1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-29T19:25:12+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>7:25 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Learning How to Learn 是我在Coursera上的一门由UC San Diego的Dr. Terrence Sejnowski, Dr. Barbara Oakley 主讲的课（你如果也喜欢这么课的话，请到www.coursera.org 搜Learning How to Learn），它是主要讲如何学习的。上了两周之后，我觉得这门课非常有用，甚至对我以后的人生都有用，所以我要把一些内容做下记录。</p>

<h1 id="procrastination">Procrastination拖延症</h1>

<p>每个人都有或多或少都有拖延症，但是有些人严重些。当你要解决一个你不喜欢的问题时，比如做数学题， 这时候你大脑中关于痛苦的区域就会被激活，与此同时，你的大脑自然而然地会激活另外一个功能–寻找舒适，于是你的大脑把注意力转向让你感到舒服的事情中去，比如做简单的事情，或者上网聊天，这似乎让你感到些快乐，但是别忘了这快乐是短暂的。所以，当你遇到困难任务是，你的大脑是这样反应的:
Unhappy felling -&gt;You funnel attention onto a more pleasant task -&gt; Feel happy(temporarily)</p>

<p>如何解决这个问题呢？我们可以借助一个工具，Pomodoro （番茄工作法），具体做法是：</p>

<blockquote>
  <ol>
    <li>25 minutes</li>
    <li>no interruptions</li>
    <li>focus</li>
    <li>reward</li>
  </ol>
</blockquote>

<p>你一定要给自己一个不受中断的25分钟，在这25分钟内你要集中精力解决问题，当问题解决完成之后别忘了给自己一个奖励，比如上网，听歌… 时间是5分钟，然后开始下个25分钟…</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/27/have-a-rest/">休息，休息一会</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-27T11:15:47+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:15 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近工作之余，我还学习和很多其他东西，由于用力过猛，加上对知识的消化、吸收工作没有做好，导致现在感觉到身体上的疲惫和心理上的焦虑。</p>

<p>所以，我要休息，休息一会！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/20/wenchangeenglish/">文昌人常说的英语</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-20T19:03:03+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>7:03 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>排球自从被华侨引进后就成了我们文昌的最热门运动，球出界的时候球员都大喊”奥赛”，它是个英语outside.   在文昌话中，螺丝刀叫”斯哥杜”, 其来源于英语”screw”.  另外我们文昌人管穿皮鞋叫穿”boots”.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/19/inspiration/">一些励志的话</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-19T17:15:38+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:15 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>尽管并不是绝对，但确实大多数事情都需要熟能生巧。做得多了，自然就擅长了；擅长了，就自然做得比别人好；做得比别人好，兴趣就大起来了，而后就更喜欢做，更擅长，更……良性循环。
但，同样，做得多就需要大量的时间投入。没兴趣，往往只不过是结果而已，却被当作不去做好的理由，最终的惩罚就是大量的时间白白流逝。
往往并不是有兴趣才能做好，而是做好了才有兴趣。
方法固然重要，但是比起“用功”来说，方法几乎可以忽略不计。所有学习上的成功，都只靠两件事：策略和坚持，而坚持本身就应该是最重要的策略。</p>

<p>事实上，没有什么要比发现、培养、呵护、调整自己的心智更重要的事情了。</p>

<p>–摘自《把时间当做朋友》</p>

<p>在你的人生中会出生很多岔道，然后呢你每一次选择就会耗去你的时间，耗去你的精力，我觉得要克服焦虑的办法，其实大概就是说你在二十岁到三十岁之间的，这一段时间的时候，在你生命力最旺盛的时候，你要想清楚几件事，第一件事你要想清楚说我这辈子最喜欢的工作是什么，就我热爱什么东西，这个是最关键的事情；第二要让自己成为一个专业的人；第三你愿意用未来的二十年时间去完成，这件你喜欢的工作和你专业的事情。</p>

<p>–摘自 《我懂你的焦虑》 吴晓波在《开讲啦》节目中的演讲</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/18/cannot-vs-can-not/">Cannot vs Can Not</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-18T19:09:22+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>7:09 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>刚才看邮件时候突然想起我平时老是分不清e.g. 和 i.e. 这两个缩写，所以特地网上查了一下。原来e.g. 是拉丁语exampli gratia 的缩写，意思是for example; 而i.e. 是拉丁语id est的缩写，意思是that is. </p>

<p>再者，我在有些邮件中看到有人写e.g.后面没有跟逗号 , 这就像for example不加逗号，这也是不对的。至于我们平常工作中用到的cannot, 比如This bug cannot be reproduced. 一般来说，我们不用can not. 看网上解释，两种用法都对，但是第一种比较常用，假如你想用can not，下面这两种情况可能符合： </p>

<ul>
  <li>
    <p>和别的词一起用，比如can not only</p>
  </li>
  <li>
    <p>表示强调，比如 No, you can not wash the dog in the Maytag.  </p>
  </li>
</ul>

<p>讲到这里，我又突然想起了，有次我开会时候的窘迫。有人跟客户电话会议，在我介绍完自己之后，老外突然来了句How are you? 我当时就懵了，心想，这时不是应该说Nice to meet you了吗？ 于是，我条件反射地说了, I am fine, and you. 于是客套来客套来，客套去。</p>

<p>有个老外程序员说，你们中国人真有趣，我说How are you的时候，你们一定会说Fine, and you，就好像一个数学函数一样。</p>

<p>但是，我们真的不知道怎么说了呀，老师又没教，也没有专门培训过。所以，跟不同的客户电话会议之前，我老是神经紧张，生怕说错了什么话，导致让对方觉得我不够礼貌。幸好说native english的老外们一般都比较nice，有时候会很开心地跟你聊，感觉就像是一个外国人说普通话，说错了我们也觉得没什么。</p>

<p>呵呵。</p>

<p>参考链接</p>

<p><a href="http://public.wsu.edu/~brians/errors/e.g.html">http://public.wsu.edu/~brians/errors/e.g.html</a></p>

<p><a href="http://www.oxforddictionaries.com/words/cannot-or-can-not">http://www.oxforddictionaries.com/words/cannot-or-can-not</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/01/learning-how-to-learn-4/">如何学习 (4)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/31/scala-2/">Scala 点滴 (2)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/31/scala-1/">Scala 点滴 (1)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/31/learning-how-to-learn-3/">如何学习 (3)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/29/learning-how-to-learn-2/">如何学习 (2)</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
  <ul id="categories">
    
	
      <li class="post">
        <a class="list-group-item active" href="/blog/categories/english/index.html">  english (2) </a>
      </li>
    
	
      <li class="post">
        <a class="list-group-item active" href="/blog/categories/others/index.html">  others (2) </a>
      </li>
    
	
      <li class="post">
        <a class="list-group-item active" href="/blog/categories/learn/index.html">  learn (4) </a>
      </li>
    
	
      <li class="post">
        <a class="list-group-item active" href="/blog/categories/scala/index.html">  scala (2) </a>
      </li>
    
  </ul>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Cando -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
