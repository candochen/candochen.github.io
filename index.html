
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>观察 记录 思考</title>
  <meta name="author" content="Cando">

  
  <meta name="description" content="模式匹配 前言
在Scala中，模式匹配（Pattern Matching）起着非常重要的作用，它不仅仅是switch的增强，而且更重要的是它提供了组合对象的析构(decomposition)能力。模式匹配之于Scala的重要性怎么强调都不过分。 但实际上，Scala不是第一个提出模式匹配概念的。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://candochen.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="观察 记录 思考" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <!--
-->
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">观察 记录 思考</a></h1>
  
    <h2>关于计算机、数学、英语和历史的点滴</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:candochen.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/17/scala-4/">Scala 点滴 (4)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-09-17T09:24:48+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>9:24 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">模式匹配</h2>

<h3 id="section-1">前言</h3>
<p>在Scala中，模式匹配（Pattern Matching）起着非常重要的作用，它不仅仅是switch的增强，而且更重要的是它提供了组合对象的析构(decomposition)能力。模式匹配之于Scala的重要性怎么强调都不过分。</p>

<p>但实际上，Scala不是第一个提出模式匹配概念的。在Scala之前，上世纪70年代中就出现了模式匹配的身影，第一个包含模式匹配概念的可能是ML语言，此后模式匹配便是很多函数式语言的标准功能，比如ML， Caml, Erlang 和 Haskell。</p>

<p>Scala语言是瑞士咯桑理工大学的Martin Ordersky教授发明的。他当时的目的是造出一种把函数式编程范式和面向对象编程范式结合到一起的编程语言。所以他肯定也会把函数式语言里的好东西(Pattern Matching)功能加入到Scala语言中来。</p>

<p>模式匹配(Pattern Matching)，如果按照我的理解来说，就是通过模式(Pattern)来匹配（Match）对象的。实际上Martin Ordersky也专门有篇论文 [http://lampwww.epfl.ch/~emir/written/MatchingObjectsWithPatterns-TR.pdf] (Matching Objects With Patterns) 来阐述Scala是如何匹配对象的。</p>

<p>这篇文章也主要本人是在该论文的基础上的学习和思考，其中可能有不完善的地方，请各位慷慨指出。</p>

<h3 id="section-2">通过模式匹配对象</h3>
<p>数据在面向对象语言中是类层次的方式存储的，比如说</p>

<h3 id="section-3">树形结构</h3>

<h3 id="partial-applied-function">偏函数(Partial Applied Function)</h3>

<h3 id="vs-visitor">模式匹配 vs 访问者模式(Visitor)</h3>

<p>我之前跟朋友说过，</p>

<blockquote>
  <p>我想谈谈GOF设计模式的存在问题（是“存在问题”，不是”存在的问题“，就是GOF设计模式为什么会存在），我觉得GOF设计模式之所以存在是因为两个方面：一方面是GOF总结了在面向对象软件开发领域所会面临的问题；另一方面是他们把这些问题分门别类，并给出了通过面向对象语言给出了相应的解决方案。假如我们只关心第二个方面（只关心解决方法），我们会发现GOF设计模式中的一些模式其实是由于面向对象编程语言引起的，假如我们的面向对象编程语言足够完美了，我们完全不需要通过GOF描述的设计方案（或者说方法）就可以解决设计模式需要解决的问题。</p>
</blockquote>

<p>而朋友说，</p>

<blockquote>
  <p>设计模式是提供了特定场景（Context）下的设计方案，这与语言没有关系吧。如果有，也是语言层面已将这些包装起来了</p>
</blockquote>

<p>针对这个讨论，我想在这里重申一下，同时坚持我以上的观点。首先来看，GOF的《Design Pattern》对一个模式Visitor模式的定义，</p>

<blockquote>
  <p>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</p>
</blockquote>

<h3 id="vs-chain-of-responsibility">模式匹配 vs 责任链模式(Chain of Responsibility)</h3>

<h3 id="section-4">参考资料</h3>

<p>http://stackoverflow.com/questions/8618082/visitor-pattern-in-scala</p>

<p>http://www.artima.com/scalazine/articles/pattern_matching.html</p>

<p><a href="Matching Objects With Patterns">http://lampwww.epfl.ch/~emir/written/MatchingObjectsWithPatterns-TR.pdf</a></p>

<p>http://www.artima.com/pins1ed/case-classes-and-pattern-matching.html</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/03/scala-3/">Scala 点滴 (3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-09-03T19:06:04+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2014</span></span> <span class='time'>7:06 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">隐式参数和隐式类型转化</h3>

<p>我想通过一个快速排序的例子，分享我对Scala中隐式参数和隐式类型转换的理解。相对于指令型语言，用Scala实现一个快速排序即简单又容易理解（代码容易阅读）。在开始之前，我想简单描述一下快速排序的思想。</p>

<p>假设我们有个无序的整数型列表，为了简单起见，它仅仅包含的5个数字分别是: 3, 4, 5, 2, 1。为了体现每个数字在排序过程中位置的变化，我把每个数字都加上下标，比如这样$3_1, 5_2, 4_3, 2_4, 1_5$。</p>

<p>让我们来看看每次排序都发生什么样的变化。</p>

<p>初始状态下
<script type="math/tex">3_1, 5_2, 4_3, 2_4, 1_5</script></p>

<p>我们现在随便选择一个数，在本例中我们选择第一个数3，然后把小于或者等于这个数的所有的数放到这个数的左边，把大于这个数的所有的数放到这个数的右边。
于是这个列表变成，
<script type="math/tex">2_1, 1_2, 3_3, 5_4, 4_5</script></p>

<p>可以看出我们选择的这个数3处于在最终应该处的位置。在上一步中，我们实际做了3件事</p>

<ol>
  <li>选一个数 （这个数叫Pivot）</li>
  <li>把小于或者等于Pivot的数放到Pivot的左边，把大于Pivot的数放到Pivot的右边 </li>
  <li>最后把这3部分合并，为了看清楚一点，我把这3部分用括号括起来</li>
</ol>

<script type="math/tex; mode=display">(2_1, 1_2) (3_3) (5_4, 4_5)</script>

<p>现在可以看出不论Pivot左边还是右边都是没有排序的，所以我们只要分别针对左边列表和右边列表重复进行以上步骤就可以了，显然这是个递归过程。（上述算法在最优条件下的时间复杂度是O(nlgn), 在最坏情况下的时间复杂度是$O(n^2)$, 可以通过随机化算法随机选择Pivot,这时候它的时间复杂度是O(nlgn), 关于这点我再这里就不多说了）</p>

<p>一切准备就绪，来看看Scala是如何简单实现快速排序的吧</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>最初的快速排序函数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def quickSort(xs: List[Int]): List[Int] = xs match {
</span><span class="line"> case Nil =&gt; Nil
</span><span class="line"> case x::xs =&gt; {
</span><span class="line">	val left = xs.filter(_&lt;=x)
</span><span class="line">	val right = xs.filter(_&gt;x)
</span><span class="line">	quickSort(left) ::: List(x) ::: quickSort(right)
</span><span class="line"> }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上述程序可以对Int型对象进行排序，能不能让它对任意的对象都可以排序呢？仔细观察一下，可以发现不同对象的比较运算符可能不一样，对于Int的对象，我们能用运算符&gt;= 或&lt; 来比较两个Int对象的大小，但是对于其他对象比较的运算符就不确定了。为了使得函数能够比较更多类型，可以增加一个比较函数作为参数传进去，于是函数变成这样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>重构一 加上泛型和比较函数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def quickSort[T](xs: List[Int])(lt: (T, T)=&gt; Boolean): List[T] = xs match {
</span><span class="line"> case Nil =&gt; Nil
</span><span class="line"> case x::xs =&gt; {
</span><span class="line">  val left = xs.filter(lt(_,x))
</span><span class="line">  val right = xs.filter(!lt(_,x))
</span><span class="line">  quickSort(left)(lt) ::: List(x) ::: quickSort(right)(lt)
</span><span class="line"> }
</span><span class="line">}
</span><span class="line">
</span><span class="line">//测试一下
</span><span class="line">def strLt(s1 : String, s2: String) = if (s1.compareTo(s2) &lt;=0) true else false
</span><span class="line">
</span><span class="line">val testList = List("scala","is", "fantastic")
</span><span class="line">
</span><span class="line">quickSort(testList)(strLt)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>重构之后, quickSort函数能够对包含任何对象的列表进行排序。但是改进仍在继续，我们可以通过定义隐式参数把第二参数也去掉。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>重构二 加上隐式参数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def quickSort[T](xs: List[Int])(implicit lt: (T, T)=&gt; Boolean): List[T] = xs match {
</span><span class="line"> case Nil =&gt; Nil
</span><span class="line"> case x::xs =&gt; {
</span><span class="line">  val left = xs.filter(lt(_,x))
</span><span class="line">  val right = xs.filter(!lt(_,x))
</span><span class="line">  quickSort(left)(lt) ::: List(x) ::: quickSort(right)(lt)
</span><span class="line"> }
</span><span class="line">}
</span><span class="line">
</span><span class="line">//测试一下
</span><span class="line">implicit def strLt(s1 : String, s2: String) = if (s1.compareTo(s2) &lt;=0) true else false
</span><span class="line">
</span><span class="line">val testList = List("scala","is", "fantastic")
</span><span class="line">
</span><span class="line">quickSort(testList)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>很神奇，对吧？ 那么隐式参数是怎么工作的呢？这要归功于Scala强大的编译器。在Scala中，隐式（implicit）意味着一个值（函数也是值-value）能够自动地传入函数中，或者一个类型的对象能够自动转化成另外一个类型的对象。具体来说implicit在Scala中有下面4种含义。</p>

<h3 id="section-1">隐式转化</h3>

<p>简单来说，如果一个函数调用一个类型为c的对象o的方法m, 这时候发现这个o对象没有方法m, 那么Scala编译器会找到一个隐式类型转化函数，把对象o从c变成另外一个有m方法的类型的对象。</p>

<p>比如 “abc”.map(_.toInt), 我们知道String类型是没有map方法的，这时Scala编译器从scala.Predef拿到适合的隐式函数(implicit def augmentString)，把”abc”从类型java.lang.String变成StringOps</p>

<p>于是，我们也可以自己定义隐式转化。比如下面程序中convertIntToOps把Int型对象转成IntOps型对象。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class IntOps(x: Int){
</span><span class="line"> def sayHi = "Hi, I am # " + x
</span><span class="line">}
</span><span class="line">
</span><span class="line">implicit def convertIntToOps(x: Int) = new IntOps(x)
</span><span class="line">println(1.sayHi)
</span><span class="line">
</span><span class="line">//以上程序打印出 Hi, I am # 1</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>可以看出隐式类型转化为Scala提供了类似动态语言的Meta-programming的能力。</p>

<h3 id="section-2">隐式参数</h3>

<p>隐式参数在 重构二 加上隐式参数 中已经说过了，这里略去重复描述。</p>

<h3 id="view-bound">View Bound</h3>

<p>在很多情况下，隐式参数和隐式类型转化被放在一起用，例如下面的例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class Container[A](implicit conv: A =&gt; Int){
</span><span class="line"> def addIt(x: A) = 123 + x
</span><span class="line">}
</span><span class="line">
</span><span class="line">implicit def strToInt(x: String) = x.toInt
</span><span class="line">
</span><span class="line">(new Container[String]).addIt("123")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更简洁的形式是Scala提供的语法糖[A &lt;% Int], 它表示有某个隐式函数把A转化成了Int，你可以像使用Int一样使用A。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>语法糖形式 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class Container[A&lt;%Int]{
</span><span class="line"> def addIt(x: A) = 123 + x
</span><span class="line">}
</span><span class="line">
</span><span class="line">implicit def strToInt(x: String) = x.toInt
</span><span class="line">
</span><span class="line">(new Container[String]).addIt("123")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们能够观察到的东西叫View，所以View Bound的意思是在某种特定的情况下(Bound: 范围)， X 可以被当做 Y使用。在语法糖形式中， A&lt;%Int, 表示类型A会被转化成Int用。</p>

<h3 id="context-bound">Context Bound</h3>

<p>implicit的另外一个用处是叫做Context Bound。Context Bound和View Bound有点不同，View Bound是把X当做Y用， 所以需要一个隐式的转化函数，就像上面的implicit def strToInt(x: String) = x.toInt。而Context Bound的意思是上下文(Context)条件下，X有一个Y。在下面代码一中，我定义一个Addable特征，同时有两个实现IntAdd和StringAdd。我把他们声明为implicit object, 目的是Container对象可以引用他们。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>代码一 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">trait Addable[T]{
</span><span class="line"> def add(x: T, y: T): T
</span><span class="line">}
</span><span class="line">  
</span><span class="line">implicit object IntAdd extends Addable[Int]{
</span><span class="line"> def add(x: Int, y: Int): Int = x + y
</span><span class="line">}
</span><span class="line">  
</span><span class="line">  
</span><span class="line">implicit object StringAdd extends Addable[String]{
</span><span class="line"> def add(x: String, y: String): String = x + y
</span><span class="line">}
</span><span class="line">  
</span><span class="line">class Container[A](implicit a: Addable[A]){
</span><span class="line"> def add(x:A, y: A) = a.add(x, y)
</span><span class="line">}
</span><span class="line">  
</span><span class="line">(new Container[Int]).add(1, 2)                  
</span><span class="line">(new Container[String]).add("a", "b")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更简洁的形式是Scala提供的语法糖[A: Addable], 它表示在你的函数或者对象（看你是把它定义在函数上还是类上）里有个Addable的对象供你使用。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>把Container写成语法糖形式</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//定义在类上
</span><span class="line">class Container[A: Addable]{
</span><span class="line">  	def add(x:A, y: A) = implicitly[Addable[A]].add(x, y)
</span><span class="line">}
</span><span class="line">  
</span><span class="line">(new Container[Int]).add(1, 2)
</span><span class="line">(new Container[String]).add("a", "b")
</span><span class="line">
</span><span class="line">//定义在函数上
</span><span class="line">def add[A: Addable](x: A, y: A) = implicitly[Addable[A]].add(x, y)
</span><span class="line">add("abc", "def")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>从上面的代码我们可以看到Container可以使用上下文中的Addable对象，也就是Container有一个Addable对象，就是我上面说的X has-a Y。</p>

<p>除了可以声明implicit object，我们还可以声明implicit class。通过implicit class，我们可以很容易地实现GOF的Adapter模式。在下面代码中，编译器“自动”地把LegacyUserService转化成UserServiceAdapter</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>用隐式类型实现一个Adapter 模式</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">trait UserService{
</span><span class="line"> def getUserRole(userId: String) : String
</span><span class="line">}
</span><span class="line">  
</span><span class="line">  
</span><span class="line">class LegacyUserService{
</span><span class="line"> def getUserRoleByUserId(userId: String) : String = {
</span><span class="line">	userId.toUpperCase()(0) + " Role"
</span><span class="line"> }
</span><span class="line">}
</span><span class="line">  
</span><span class="line">  
</span><span class="line">implicit class UserServiceAdapter(legacyUserService : LegacyUserService) extends UserService{
</span><span class="line"> def getUserRole(userId: String) = {
</span><span class="line">	legacyUserService.getUserRoleByUserId(userId)
</span><span class="line"> }
</span><span class="line">}
</span><span class="line">
</span><span class="line"> 
</span><span class="line">val userService: UserService = new LegacyUserService()
</span><span class="line">                                                   	
</span><span class="line">println(userService.getUserRole("alex"))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这篇文章的信息量有点大，这和我之前想象的不同，它也花费了我将近一个星期的下班后时间。在边写边思考的过程中，我学到了很多东西。</p>

<h4 id="section-3">参考资料</h4>

<p><a href="">http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html</a></p>

<p><a href="">http://www.scala-lang.org/api/current/index.html#scala.math.Ordering</a></p>

<p><a href="">http://www.scala-lang.org/docu/files/ScalaByExample.pdf</a></p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/01/learning-how-to-learn-4/">如何学习 (4)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-09-01T09:26:39+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>9:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="section">睡眠很重要</h2>

<p>你在清醒中学习的时候你的大脑会分泌出毒素。那你的大脑是如何排出这些毒素的呢？答案就是：睡觉。</p>

<p>当你睡觉的时候，你的脑细胞就会收缩</p>

<blockquote>
  <p>Turns out that when you sleep, your brain cells shrink.</p>
</blockquote>

<p>因此细胞之间的空隙就会增大。这就像是打开了一个水龙头，流体流过大脑细胞间隙的时候，也就把毒素给排出去了。</p>

<blockquote>
  <p>Fluid can flow past these cells and wash the toxins out.</p>
</blockquote>

<p>有时候你可能会觉得睡觉挺浪费时间的，但是这是有回报的：你的大脑更加干净和健康。</p>

<p>实际上，缺乏睡眠不仅对你的大脑健康造成损害，而且对你的健康还造成影响，比如会导致心脏病，头疼，抑郁，等等。</p>

<p>当然过多的睡眠跟过少的睡眠是一样的。</p>

<p>充足的睡眠除了对你的健康有益外，对你的学习也大有裨益。</p>

<blockquote>
  <p>Sleep has also been shown to make a remarkable difference in your ability to figure out difficult problems and to understand what you’re trying to learn.</p>
</blockquote>

<p>在你睡觉的时候，负责你意识清醒的大脑前额皮质会松弛下来，这给激活大脑其他的区域创造了机会。于是这些在你睡觉的时候依然工作的大脑各个区域组成解决你学习任务的神经系统。</p>

<p>在你打盹或者睡觉之前，如果你集中精力思考一个问题，你可能会梦到你所思考的问题。而梦到你所思考的问题还会增加你理解问题的能力。</p>

<p>所以充足的睡眠是你学习的一部分，不要再觉得睡觉浪费时间了。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/scala-2/">Scala 点滴 (2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T11:20:58+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>11:20 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="scala">Scala函数之初体验</h2>

<p>下面这个例子是Scala发明者Martin Odersky在Coursera上授课用的例子，这个例子在SICP(Structure and Interpretation of Computer Programs, 计算机程序的构造和解释)一书中也有。我这里重述这个例子的原因是这个例子即包含数学思想又包含Scala语法，它即实用又有趣。</p>

<p>它就是，</p>

<h3 id="sqrt2">通过牛顿法求$\sqrt{2}$的近似值</h3>

<p>从这篇维基百科<a href="http://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法介绍</a> 我们可以知道，牛顿法是一种迭代方法。所谓迭代的意思是上一次计算的结果都对本次计算起作用，换句话说，上次计算得出的结果可以作为本次计算的输入。</p>

<p>本文主要讲述如果用Scala实现牛顿法，所以牛顿法的分析过程就此略过，而直接给出公式：</p>

<script type="math/tex; mode=display">x_{n+1} = x_n - \frac{f(x_n)}{f'(x_{n})}</script>

<p>而$\sqrt{2}$就是$f(x) = x^2 - 2 = 0$的根，根据上面的公式通过求得</p>

<script type="math/tex; mode=display">x_{n+1} = \frac{x_n + \frac{2}{x_n}}{2}</script>

<p>现在只要给出一个初始值$x_0$就可以通过上面的迭代公式求出结果。因为$f(x) = x^2 - 2 = 0$，所以$x^2=2$，易知1&lt;x&lt;2。因此，我们可以给出一个初始值$x_0 = 1 $ 。</p>

<p>一切准备工作就绪，我可以编程了…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">def isGoodEnough(guess: Double) = 
</span><span class="line">	abs(guess * guess - 2) &lt; 0.000001
</span><span class="line">
</span><span class="line">//这个就是迭代公式
</span><span class="line">def improve(guess: Double) = (guess + 2/guess) / 2
</span><span class="line">
</span><span class="line">//迭代函数,迭代函数必须有返回值类型
</span><span class="line">def iter(guess: Double):Double = {
</span><span class="line">	if (isGoodEnough(guess)) guess
</span><span class="line">	else iter(improve(guess))
</span><span class="line">}
</span><span class="line">
</span><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt2 = iter(1)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>学过编程的人都会觉得上面的程序好傻。首先，这个sqrt2只能够求$\sqrt{2}$的值，它不能求$\sqrt{3} , \sqrt{5} …$, 其次isGoodEnough函数的精度不能写死了，总之不够灵活(flexible)。</p>

<p>所以，我进行第一次重构…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>第一次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">val precision = 0.000001
</span><span class="line">
</span><span class="line">//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">def isGoodEnough(guess: Double, x: Double) = 
</span><span class="line">	abs(guess * guess - x) &lt; precision
</span><span class="line">
</span><span class="line">//这个就是迭代公式
</span><span class="line">def improve(guess: Double, x: Double) = (guess + x/guess) / 2
</span><span class="line">
</span><span class="line">//迭代函数,迭代函数必须有返回值类型
</span><span class="line">def iter(guess: Double, x: Double):Double = {
</span><span class="line">	if (isGoodEnough(guess, x)) guess
</span><span class="line">	else iter(improve(guess, x), x)
</span><span class="line">}
</span><span class="line">
</span><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt(x: Double) = iter(1, x)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>经过一次重构，程序比第一次好些了，但是还有个问题：因为isGoodEnough, improve, iter这些函数都是sqrt函数计算的一部分，能不能把它们封装到函数sqrt里面呢？ 答案是可以的，这也正是Scala的一个优点（相对于Java）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>第二次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt(x: Double)  = {
</span><span class="line">	val precision = 0.000001
</span><span class="line">	
</span><span class="line">	//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">	def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">	//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">	def isGoodEnough(guess: Double, x: Double) = 
</span><span class="line">		abs(guess * guess - x) &lt; precision
</span><span class="line">
</span><span class="line">	//这个就是迭代公式
</span><span class="line">	def improve(guess: Double, x: Double) = (guess + x/guess) / 2
</span><span class="line">
</span><span class="line">	//迭代函数,迭代函数必须有返回值类型
</span><span class="line">	def iter(guess: Double, x: Double):Double = {
</span><span class="line">		if (isGoodEnough(guess, x)) guess
</span><span class="line">		else iter(improve(guess, x), x)
</span><span class="line">	}	
</span><span class="line">	
</span><span class="line">	iter(1, x)
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过上述函数sqrt算出$\sqrt{2} = 1.4142135623746899 , \sqrt{3} = 1.7320508100147274$</p>

<p>至此，假如你刚学Scala，我相信这个例子能给一些Scala函数的初步印象，比如函数的形式，再比如函数里面嵌套函数，但这绝对不是Scala函数的全貌。要知道函数在Scala里可是first-class citizen (头等公民)，关于这点我在后续文章里会有分享。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/scala-1/">Scala 点滴 (1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T11:06:48+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>11:06 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在Coursera上学习Scala编程有两个月了， Scala的基础课程即将结束。在新的课程《响应式编程》开始之前，我想总结一下。</p>

<h2 id="section">编程范式</h2>

<p>如果我们把现在的编程范式做下分类，我们可以分成3类：</p>

<blockquote>
  <ol>
    <li>指令编程范式</li>
    <li>函数编程范式</li>
    <li>逻辑编程范式</li>
  </ol>
</blockquote>

<p>而以上每种编程范式都与面向对象编程范式正交，意思是说指令型编程语言可以拥有面向对象特征，同理其他两种编程范式都可以拥有面向对象的特征。</p>

<p>所谓指令型编程语言范式是从冯. 诺依曼的计算机模型引申而来的，它的特点正如冯.诺依曼模型一样，运行时通过总线把它把指令和数据从内存加载到CPU，然后把结果又送回去。
更具体地说，指令编程范式对于于冯.诺依曼计算机模型有一种对应关系，</p>

<blockquote>
  <ol>
    <li>变量 相对于 内存单元</li>
    <li>释放变量  相对于 load 指令</li>
    <li>变量赋值  相对于 store 指令  </li>
    <li>分支控制  相对于 jump 指令</li>
  </ol>
</blockquote>

<p>在严格定义下，函数式编程范式则有以下特点</p>

<blockquote>
  <ol>
    <li>没有变量，也就没有对变量赋值</li>
    <li>没有指令编程范式的控制结构，例如while，loop等等</li>
    <li>函数是函数式编程范式里的头等公民，这意味着函数，就像普通值一样，可以在任何地方定义，包括在其他函数里面；此外，函数也像普通值一样，可以作为参数传到其他函数里，或作为结果返回，当然我们也可以对函数定义一下操作符用于把函数组合起来。</li>
  </ol>
</blockquote>

<p>假如我宽泛地给函数式编程范式给个定义，我们可以说，函数式编程范式主要是一种关注函数的编程范式。</p>

<p>至于逻辑编程范式，由于Martin Ordersky并没有给出解释，所以这里也略过。</p>

<p>在市面上的流行语言中，如果根据以上编程范式分类，函数式编程语言看起来应该像这样子</p>

<ol>
  <li>
    <p>严格定义下的函数式编程语言</p>

    <blockquote>
      <p>Pure Lisp, XSLT, XPath, XQuery, FP
 Haskell (without I/O Monad or UnsafePerformIO)</p>
    </blockquote>
  </li>
  <li>
    <p>广义定义下的函数式编程语言</p>

    <blockquote>
      <p>Lisp, Scheme, Racket, Clojure
SML, Ocaml, F#
Haskell (full language)
Scala
Smalltalk, Ruby (!)</p>
    </blockquote>
  </li>
</ol>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/31/learning-how-to-learn-3/">如何学习 (3)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-31T10:32:53+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>10:32 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="long-term-memory-working-memory-">Long term memory Working Memory 长期记忆和工作记忆</h2>
<p>假如你要回忆童年往事或者数学公式，你用的是人脑中负责长期记忆的long term memory；假如你想把其中一些概念联系起来解决某些问题，你要的是working memory。
你有时候会把一些记忆从long term memory取出，然后放到working memory里，这时候long term memory就和working memory发生了联系。（我觉得，就这working memory 和 long term memory的关系来说，很像计算机中内存和硬盘的关系–当信息需要长期存储的时候它被放到硬盘中；当它需要被处理的时候，把它载到内存中处理。）</p>

<p>表面上来看，working memory就像一个黑盒子，但是这个盒子里面的东西是很容易模糊的，比如你要写下一串数字，你需要重复好几次才能把它记得，然后才能写下来。</p>

<p>当你学习新事物的时候，你使用working memory。</p>

<p>Long term memory非常重要，你的解决问题的技巧等等都存放在long term memory里，于是你需要往long term memory里存放信息。</p>

<p>当你第一次把某信息放入long term memory，你起码需要重复“访问”它几次，这样你才能增加下次找到它的几率。同时不同的item在long term memory里还可能会相互覆盖，这时候你需要更多的练习才可能从这相互覆盖的区域找到你想要的东西。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/29/learning-how-to-learn-2/">如何学习 (2)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-29T20:23:11+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>8:23 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1 id="practice-makes-permanent">Practice makes permanent</h1>

<p>Bard 老师从16岁才开始真正地学习数学，在那之前她非常害怕和痛恨学习数学和科学。她没想到她后来回从事工程(engineering)的工作。刚开始的时候，她觉得数学太难了，在她看来数学对其他同学来说是那么容易–他们学得又快又准。在学习过程中，她有时候会放下学习，到外面的世界去逛逛，回来之后再继续学。她说，她不是自然就学会数学的，而是一步一步、循序渐进地学习得来的。</p>

<p>数学是抽象的，它不容易掌握，不像具体的事物，比如一头奶牛，你知道cow是奶牛的意思，你可以对着奶牛指着它，看着它学习cow。 但是数学通常情况下没有类似的东西让你比较，让你联系。当然你可以说，类似“爱”，“希望”这些词也是抽象的，但是通常这些词可以从人的情感中找到联系，但是数学概念不行。</p>

<p>正是因为数学是抽象的，我们需要不停地练习以强化数学思想。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/29/learning-how-to-learn-1/">如何学习 (1)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-29T19:25:12+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>7:25 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Learning How to Learn 是我在Coursera上的一门由UC San Diego的Dr. Terrence Sejnowski, Dr. Barbara Oakley 主讲的课（你如果也喜欢这么课的话，请到www.coursera.org 搜Learning How to Learn），它是主要讲如何学习的。上了两周之后，我觉得这门课非常有用，甚至对我以后的人生都有用，所以我要把一些内容做下记录。</p>

<h1 id="procrastination">Procrastination拖延症</h1>

<p>每个人都有或多或少都有拖延症，但是有些人严重些。当你要解决一个你不喜欢的问题时，比如做数学题， 这时候你大脑中关于痛苦的区域就会被激活，与此同时，你的大脑自然而然地会激活另外一个功能–寻找舒适，于是你的大脑把注意力转向让你感到舒服的事情中去，比如做简单的事情，或者上网聊天，这似乎让你感到些快乐，但是别忘了这快乐是短暂的。所以，当你遇到困难任务是，你的大脑是这样反应的:
Unhappy felling -&gt;You funnel attention onto a more pleasant task -&gt; Feel happy(temporarily)</p>

<p>如何解决这个问题呢？我们可以借助一个工具，Pomodoro （番茄工作法），具体做法是：</p>

<blockquote>
  <ol>
    <li>25 minutes</li>
    <li>no interruptions</li>
    <li>focus</li>
    <li>reward</li>
  </ol>
</blockquote>

<p>你一定要给自己一个不受中断的25分钟，在这25分钟内你要集中精力解决问题，当问题解决完成之后别忘了给自己一个奖励，比如上网，听歌… 时间是5分钟，然后开始下个25分钟…</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/27/have-a-rest/">休息，休息一会</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-27T11:15:47+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:15 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近工作之余，我还学习和很多其他东西，由于用力过猛，加上对知识的消化、吸收工作没有做好，导致现在感觉到身体上的疲惫和心理上的焦虑。</p>

<p>所以，我要休息，休息一会！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/20/wenchangeenglish/">文昌人常说的英语</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-08-20T19:03:03+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>7:03 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>排球自从被华侨引进后就成了我们文昌的最热门运动，球出界的时候球员都大喊”奥赛”，它是个英语outside.   在文昌话中，螺丝刀叫”斯哥杜”, 其来源于英语”screw”.  另外我们文昌人管穿皮鞋叫穿”boots”.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/17/scala-4/">Scala 点滴 (4)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/03/scala-3/">Scala 点滴 (3)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/01/learning-how-to-learn-4/">如何学习 (4)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/31/scala-2/">Scala 点滴 (2)</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/31/scala-1/">Scala 点滴 (1)</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Categories</h1>
  <ul id="categories">
    
	
      <li class="post">
        <a class="list-group-item active" href="/blog/categories/english/index.html">  english (2) </a>
      </li>
    
	
      <li class="post">
        <a class="list-group-item active" href="/blog/categories/others/index.html">  others (2) </a>
      </li>
    
	
      <li class="post">
        <a class="list-group-item active" href="/blog/categories/learn/index.html">  learn (4) </a>
      </li>
    
	
      <li class="post">
        <a class="list-group-item active" href="/blog/categories/scala/index.html">  scala (4) </a>
      </li>
    
  </ul>
</section><section>
<h1>最近评论</h1>
<ul class="ds-recent-comments" data-num-items="10">
</ul>
<!--多说js加载开始，一个页面只需要加载一次 -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"candochen"};
(function() {
var ds = document.createElement('script');
ds.type = 'text/javascript';
ds.async = true;ds.src = 'http://static.duoshuo.com/embed.js';
ds.charset = 'UTF-8';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!--多说js加载结束，一个页面只需要加载一次 -->
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Cando -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
