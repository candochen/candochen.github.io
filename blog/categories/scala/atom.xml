<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | 观察 记录 思考]]></title>
  <link href="http://candochen.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://candochen.github.io/"/>
  <updated>2014-09-02T20:57:14+08:00</updated>
  <id>http://candochen.github.io/</id>
  <author>
    <name><![CDATA[Cando]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scala 点滴 (2)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/31/scala-2/"/>
    <updated>2014-08-31T11:20:58+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/31/scala-2</id>
    <content type="html"><![CDATA[<h2 id="scala">Scala函数之初体验</h2>

<p>下面这个例子是Scala发明者Martin Odersky在Coursera上授课用的例子，这个例子在SICP(Structure and Interpretation of Computer Programs, 计算机程序的构造和解释)一书中也有。我这里重述这个例子的原因是这个例子即包含数学思想又包含Scala语法，它即实用又有趣。</p>

<p>它就是，</p>

<h3 id="sqrt2">通过牛顿法求$\sqrt{2}$的近似值</h3>

<p>从这篇维基百科<a href="http://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法介绍</a> 我们可以知道，牛顿法是一种迭代方法。所谓迭代的意思是上一次计算的结果都对本次计算起作用，换句话说，上次计算得出的结果可以作为本次计算的输入。</p>

<p>本文主要讲述如果用Scala实现牛顿法，所以牛顿法的分析过程就此略过，而直接给出公式：</p>

<script type="math/tex; mode=display">x_{n+1} = x_n - \frac{f(x_n)}{f'(x_{n})}</script>

<p>而$\sqrt{2}$就是$f(x) = x^2 - 2 = 0$的根，根据上面的公式通过求得</p>

<script type="math/tex; mode=display">x_{n+1} = \frac{x_n + \frac{2}{x_n}}{2}</script>

<p>现在只要给出一个初始值$x_0$就可以通过上面的迭代公式求出结果。因为$f(x) = x^2 - 2 = 0$，所以$x^2=2$，易知1&lt;x&lt;2。因此，我们可以给出一个初始值$x_0 = 1 $ 。</p>

<p>一切准备工作就绪，我可以编程了…</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class='line'>def abs(x: Double) = if(x &gt;=0) x else -x&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class='line'>def isGoodEnough(guess: Double) = 
</span><span class='line'>	abs(guess * guess - 2) &lt; 0.000001&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//这个就是迭代公式
</span><span class='line'>def improve(guess: Double) = (guess + 2/guess) / 2&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//迭代函数,迭代函数必须有返回值类型
</span><span class='line'>def iter(guess: Double):Double = {
</span><span class='line'>	if (isGoodEnough(guess)) guess
</span><span class='line'>	else iter(improve(guess))
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//求根函数, 传入迭代的初始值 1
</span><span class='line'>def sqrt2 = iter(1)     &lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>学过编程的人都会觉得上面的程序好傻。首先，这个sqrt2只能够求$\sqrt{2}$的值，它不能求$\sqrt{3} , \sqrt{5} …$, 其次isGoodEnough函数的精度不能写死了，总之不够灵活(flexible)。</p>

<p>所以，我进行第一次重构…</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>第一次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>val precision = 0.000001&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class='line'>def abs(x: Double) = if(x &gt;=0) x else -x&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class='line'>def isGoodEnough(guess: Double, x: Double) = 
</span><span class='line'>	abs(guess * guess - x) &lt; precision&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//这个就是迭代公式
</span><span class='line'>def improve(guess: Double, x: Double) = (guess + x/guess) / 2&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//迭代函数,迭代函数必须有返回值类型
</span><span class='line'>def iter(guess: Double, x: Double):Double = {
</span><span class='line'>	if (isGoodEnough(guess, x)) guess
</span><span class='line'>	else iter(improve(guess, x), x)
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//求根函数, 传入迭代的初始值 1
</span><span class='line'>def sqrt(x: Double) = iter(1, x)&lt;br /></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>经过一次重构，程序比第一次好些了，但是还有个问题：因为isGoodEnough, improve, iter这些函数都是sqrt函数计算的一部分，能不能把它们封装到函数sqrt里面呢？ 答案是可以的，这也正是Scala的一个优点（相对于Java）。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>第二次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//求根函数, 传入迭代的初始值 1
</span><span class='line'>def sqrt(x: Double)  = {
</span><span class='line'>	val precision = 0.000001&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class='line'>def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class='line'>
</span><span class='line'>//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class='line'>def isGoodEnough(guess: Double, x: Double) = 
</span><span class='line'>	abs(guess * guess - x) &lt; precision
</span><span class='line'>
</span><span class='line'>//这个就是迭代公式
</span><span class='line'>def improve(guess: Double, x: Double) = (guess + x/guess) / 2
</span><span class='line'>
</span><span class='line'>//迭代函数,迭代函数必须有返回值类型
</span><span class='line'>def iter(guess: Double, x: Double):Double = {
</span><span class='line'>	if (isGoodEnough(guess, x)) guess
</span><span class='line'>	else iter(improve(guess, x), x)
</span><span class='line'>}	
</span><span class='line'>
</span><span class='line'>iter(1, x) }</span></code></pre></td></tr></table></div></figure></notextile></div>
</code></pre>

<p>通过上述函数sqrt算出$\sqrt{2} = 1.4142135623746899 , \sqrt{3} = 1.7320508100147274$</p>

<p>至此，假如你刚学Scala，我相信这个例子能给一些Scala函数的初步印象，比如函数的形式，再比如函数里面嵌套函数，但这绝对不是Scala函数的全貌。要知道函数在Scala里可是first-class citizen (头等公民)，关于这点我在后续文章里会有分享。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 点滴 (1)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/31/scala-1/"/>
    <updated>2014-08-31T11:06:48+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/31/scala-1</id>
    <content type="html"><![CDATA[<p>在Coursera上学习Scala编程有两个月了， Scala的基础课程即将结束。在新的课程《响应式编程》开始之前，我想总结一下。</p>

<h2 id="section">编程范式</h2>

<p>如果我们把现在的编程范式做下分类，我们可以分成3类：</p>

<blockquote>
  <ol>
    <li>指令编程范式</li>
    <li>函数编程范式</li>
    <li>逻辑编程范式</li>
  </ol>
</blockquote>

<p>而以上每种编程范式都与面向对象编程范式正交，意思是说指令型编程语言可以拥有面向对象特征，同理其他两种编程范式都可以拥有面向对象的特征。</p>

<p>所谓指令型编程语言范式是从冯. 诺依曼的计算机模型引申而来的，它的特点正如冯.诺依曼模型一样，运行时通过总线把它把指令和数据从内存加载到CPU，然后把结果又送回去。
更具体地说，指令编程范式对于于冯.诺依曼计算机模型有一种对应关系，</p>

<blockquote>
  <ol>
    <li>变量 相对于 内存单元</li>
    <li>释放变量  相对于 load 指令</li>
    <li>变量赋值  相对于 store 指令  </li>
    <li>分支控制  相对于 jump 指令</li>
  </ol>
</blockquote>

<p>在严格定义下，函数式编程范式则有以下特点</p>

<blockquote>
  <ol>
    <li>没有变量，也就没有对变量赋值</li>
    <li>没有指令编程范式的控制结构，例如while，loop等等</li>
    <li>函数是函数式编程范式里的头等公民，这意味着函数，就像普通值一样，可以在任何地方定义，包括在其他函数里面；此外，函数也像普通值一样，可以作为参数传到其他函数里，或作为结果返回，当然我们也可以对函数定义一下操作符用于把函数组合起来。</li>
  </ol>
</blockquote>

<p>假如我宽泛地给函数式编程范式给个定义，我们可以说，函数式编程范式主要是一种关注函数的编程范式。</p>

<p>至于逻辑编程范式，由于Martin Ordersky并没有给出解释，所以这里也略过。</p>

<p>在市面上的流行语言中，如果根据以上编程范式分类，函数式编程语言看起来应该像这样子</p>

<ol>
  <li>
    <p>严格定义下的函数式编程语言</p>

    <blockquote>
      <p>Pure Lisp, XSLT, XPath, XQuery, FP
 Haskell (without I/O Monad or UnsafePerformIO)</p>
    </blockquote>
  </li>
  <li>
    <p>广义定义下的函数式编程语言</p>

    <blockquote>
      <p>Lisp, Scheme, Racket, Clojure
SML, Ocaml, F#
Haskell (full language)
Scala
Smalltalk, Ruby (!)</p>
    </blockquote>
  </li>
</ol>
]]></content>
  </entry>
  
</feed>
