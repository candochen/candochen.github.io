<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scala | 观察 记录 思考]]></title>
  <link href="http://candochen.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://candochen.github.io/"/>
  <updated>2016-05-30T10:53:01+08:00</updated>
  <id>http://candochen.github.io/</id>
  <author>
    <name><![CDATA[Cando]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Observable]]></title>
    <link href="http://candochen.github.io/blog/2016/05/03/observable/"/>
    <updated>2016-05-03T19:26:15+08:00</updated>
    <id>http://candochen.github.io/blog/2016/05/03/observable</id>
    <content type="html"><![CDATA[<p>In the Reactive Programming course, Erik Meijer introduced 4 essential effects in programming. This text is intended to describe the essential effects in my own way, with examples. </p>

<p>Let’s begin with simple functions, which return one or many values synchronously.  As shown in the below diagram, the getValue function returns a value of type T, and getValues returns an iterable of type T. </p>

<p>Figure 1</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: right">One</th>
      <th style="text-align: right">Many</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Synchronous</td>
      <td style="text-align: right">T/Try[T]</td>
      <td style="text-align: right">Iterable[T]</td>
    </tr>
    <tr>
      <td>Asynchronous</td>
      <td style="text-align: right">Future[T]</td>
      <td style="text-align: right">Observable[T]</td>
    </tr>
  </tbody>
</table>

<h1 id="exception">Exception</h1>
<p>Developers should know that apart from the normal case, there exist exceptions. For example, 
exception will occur if users enter 0 as the divisor in the below function.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def divide(dividend: Double, divisor : Double) : Double = {
</span><span class='line'>    dividend / divisor
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>In order to handle the case when exception happens, we should wrap the computation within a Try monad. So the code should be </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def divide(dividend: Double, divisor : Double) : Try[Double] = {
</span><span class='line'>    Try(dividend / divisor)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>User of this function will be aware of the Try[Double]. It is very comprehensive. This function reads like “try to get a value of Double type by invoking the function divide” literally.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>val result = divide(divident, divisor)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>result match {
</span><span class='line'>	case Success(v) =&gt; println(v)
</span><span class='line'>	case Failure(e) =&gt; println(e)
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Likewise, a function returning many values may have exceptions as well. In such case, what we need to do is to define the function as </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def getValue: Try[Iterable[T]]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Til now, we know that functions may have exceptions. In order to notify users of the function, developers should have computation wrapped within a Try monad. So after considering exceptions, the table becomes:</p>

<h1 id="latency">Latency</h1>

<p>Besides exceptions, one term in computer programming we should consider is Latency. Latency by narrow definition in computer programming is: </p>

<blockquote>
  <p>Latency is the amount of time a message takes to traverse a system. In a computer network, it is an expression of how much time it takes for a packet of data to get from one designated point to another. It is sometimes measured as the time required for a packet to be returned to its sender.</p>
</blockquote>

<p>From my perspective, if any computation that is expected to be slower than another computation, then there exists latency for the slower computation relatively. For example, getFromNetwork has latency comparing with getFromRAM.</p>

<p>In order to handle the expected latency, we can make use of Future. Future by definition of Scala developer guide is as blow:</p>

<blockquote>
  <p>A Future is an object holding a value which may become available at some point.</p>
</blockquote>

<p>Technically, </p>

<p>Let’s look at an example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>import scala.concurrent._&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>import ExecutionContext.Implicits.global&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>import scala.util.{Success, Failure}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>object Weather extends App{&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>	val weatherFuture  = Future {
</span><span class='line'>		//WeatherInfoRestService.getWeatherInfo is a function that requests resource from internet via REST
</span><span class='line'>		WeatherInfoRestService.getWeatherInfo
</span><span class='line'>	}
</span><span class='line'>	
</span><span class='line'>	
</span><span class='line'>	//register a callback
</span><span class='line'>	weatherFuture onSuccess {
</span><span class='line'>	  case x =&gt; println(x)
</span><span class='line'>		  		 
</span><span class='line'>	}
</span><span class='line'>  
</span><span class='line'>	weatherFuture onFailure {
</span><span class='line'>	  case e =&gt; println(e)
</span><span class='line'>	}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>} &lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Til now, we know that functions may have exceptions. In order to notify users of the function, developers should have computation wrapped within a Try monad. So after considering exceptions, the table becomes:</p>

<h1 id="from-future-to-observable">From Future to Observable</h1>

<p><img class="left" src="/images/20160527/stream.png" width="700" height="350" title="‘image’ ‘images’" > </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>package akka
</span><span class='line'>import org.apache.commons.io.monitor._
</span><span class='line'>import scala.util._
</span><span class='line'>import java.io.File
</span><span class='line'>import rx.lang.scala._&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>object FileMonitor extends App {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>def monitor(directory: String): Observable[String] = {
</span><span class='line'>    Observable.create {
</span><span class='line'>    	observer =&gt; 
</span><span class='line'>    	  val fileMonitor = new FileAlterationMonitor(1000)
</span><span class='line'>    	  val fileObserver = new FileAlterationObserver(directory)
</span><span class='line'>    	  val fileLsnr = new FileAlterationListenerAdaptor{
</span><span class='line'>    		 override def onFileChange(file: File){
</span><span class='line'>    		   observer.onNext(file.getCanonicalPath())
</span><span class='line'>    		 }
</span><span class='line'>    		 
</span><span class='line'>    		 override def onFileCreate(file: File){
</span><span class='line'>    		   observer.onNext(file.getCanonicalPath())
</span><span class='line'>    		 }
</span><span class='line'>    		 
</span><span class='line'>    		 override def onFileDelete(file: File){
</span><span class='line'>    		   observer.onNext(file.getCanonicalPath())
</span><span class='line'>    		 }
</span><span class='line'>    	  }
</span><span class='line'>    	 fileObserver.addListener(fileLsnr)
</span><span class='line'>    	 fileMonitor.addObserver(fileObserver)
</span><span class='line'>    	 fileMonitor.start()
</span><span class='line'>    	 Subscription ()
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//Test to monitor a directory
</span><span class='line'>val o = monitor("D:\\src")
</span><span class='line'>o.filter(x =&gt; x.endsWith("xml")).subscribe{
</span><span class='line'>  x =&gt; println(x)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>o.filter(x =&gt; x.endsWith("txt")).subscribe{
</span><span class='line'>  x =&gt; println(x)
</span><span class='line'>} }
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h1 id="wrap-up">Wrap-up</h1>

<p>In computer programming, </p>

<p>I am gonna deep-dive into each </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 点滴 (3)]]></title>
    <link href="http://candochen.github.io/blog/2014/09/03/scala-3/"/>
    <updated>2014-09-03T19:06:04+08:00</updated>
    <id>http://candochen.github.io/blog/2014/09/03/scala-3</id>
    <content type="html"><![CDATA[<h3 id="section">隐式参数和隐式类型转化</h3>

<p>我想通过一个快速排序的例子，分享我对Scala中隐式参数和隐式类型转换的理解。相对于指令型语言，用Scala实现一个快速排序即简单又容易理解（代码容易阅读）。在开始之前，我想简单描述一下快速排序的思想。</p>

<p>假设我们有个无序的整数型列表，为了简单起见，它仅仅包含的5个数字分别是: 3, 4, 5, 2, 1。为了体现每个数字在排序过程中位置的变化，我把每个数字都加上下标，比如这样$3_1, 5_2, 4_3, 2_4, 1_5$。</p>

<p>让我们来看看每次排序都发生什么样的变化。</p>

<p>初始状态下
<script type="math/tex">3_1, 5_2, 4_3, 2_4, 1_5</script></p>

<p>我们现在随便选择一个数，在本例中我们选择第一个数3，然后把小于或者等于这个数的所有的数放到这个数的左边，把大于这个数的所有的数放到这个数的右边。
于是这个列表变成，
<script type="math/tex">2_1, 1_2, 3_3, 5_4, 4_5</script></p>

<p>可以看出我们选择的这个数3处于在最终应该处的位置。在上一步中，我们实际做了3件事</p>

<ol>
  <li>选一个数 （这个数叫Pivot）</li>
  <li>把小于或者等于Pivot的数放到Pivot的左边，把大于Pivot的数放到Pivot的右边 </li>
  <li>最后把这3部分合并，为了看清楚一点，我把这3部分用括号括起来</li>
</ol>

<script type="math/tex; mode=display">(2_1, 1_2) (3_3) (5_4, 4_5)</script>

<p>现在可以看出不论Pivot左边还是右边都是没有排序的，所以我们只要分别针对左边列表和右边列表重复进行以上步骤就可以了，显然这是个递归过程。（上述算法在最优条件下的时间复杂度是O(nlgn), 在最坏情况下的时间复杂度是$O(n^2)$, 可以通过随机化算法随机选择Pivot,这时候它的时间复杂度是O(nlgn), 关于这点我再这里就不多说了）</p>

<p>一切准备就绪，来看看Scala是如何简单实现快速排序的吧</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>最初的快速排序函数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def quickSort(xs: List[Int]): List[Int] = xs match {
</span><span class='line'> case Nil =&gt; Nil
</span><span class='line'> case x::xs =&gt; {
</span><span class='line'>	val left = xs.filter(&lt;em>&lt;=x)
</span><span class='line'>	val right = xs.filter(&lt;/em>&gt;x)
</span><span class='line'>	quickSort(left) ::: List(x) ::: quickSort(right)
</span><span class='line'> }
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上述程序可以对Int型对象进行排序，能不能让它对任意的对象都可以排序呢？仔细观察一下，可以发现不同对象的比较运算符可能不一样，对于Int的对象，我们能用运算符&gt;= 或&lt; 来比较两个Int对象的大小，但是对于其他对象比较的运算符就不确定了。为了使得函数能够比较更多类型，可以增加一个比较函数作为参数传进去，于是函数变成这样</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>重构一 加上泛型和比较函数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def quickSort&lt;a href="xs: List[Int]">T&lt;/a>(lt: (T, T)=&gt; Boolean): List[T] = xs match {
</span><span class='line'> case Nil =&gt; Nil
</span><span class='line'> case x::xs =&gt; {
</span><span class='line'>  val left = xs.filter(lt(&lt;em>,x))
</span><span class='line'>  val right = xs.filter(!lt(&lt;/em>,x))
</span><span class='line'>  quickSort(left)(lt) ::: List(x) ::: quickSort(right)(lt)
</span><span class='line'> }
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//测试一下
</span><span class='line'>def strLt(s1 : String, s2: String) = if (s1.compareTo(s2) &lt;=0) true else false&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>val testList = List(“scala”,”is”, “fantastic”)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>quickSort(testList)(strLt)</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>重构之后, quickSort函数能够对包含任何对象的列表进行排序。但是改进仍在继续，我们可以通过定义隐式参数把第二参数也去掉。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>重构二 加上隐式参数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def quickSort&lt;a href="xs: List[Int]">T&lt;/a>(implicit lt: (T, T)=&gt; Boolean): List[T] = xs match {
</span><span class='line'> case Nil =&gt; Nil
</span><span class='line'> case x::xs =&gt; {
</span><span class='line'>  val left = xs.filter(lt(&lt;em>,x))
</span><span class='line'>  val right = xs.filter(!lt(&lt;/em>,x))
</span><span class='line'>  quickSort(left)(lt) ::: List(x) ::: quickSort(right)(lt)
</span><span class='line'> }
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//测试一下
</span><span class='line'>implicit def strLt(s1 : String, s2: String) = if (s1.compareTo(s2) &lt;=0) true else false&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>val testList = List(“scala”,”is”, “fantastic”)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>quickSort(testList)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>很神奇，对吧？ 那么隐式参数是怎么工作的呢？这要归功于Scala强大的编译器。在Scala中，隐式（implicit）意味着一个值（函数也是值-value）能够自动地传入函数中，或者一个类型的对象能够自动转化成另外一个类型的对象。具体来说implicit在Scala中有下面4种含义。</p>

<h3 id="section-1">隐式转化</h3>

<p>简单来说，如果一个函数调用一个类型为c的对象o的方法m, 这时候发现这个o对象没有方法m, 那么Scala编译器会找到一个隐式类型转化函数，把对象o从c变成另外一个有m方法的类型的对象。</p>

<p>比如 “abc”.map(_.toInt), 我们知道String类型是没有map方法的，这时Scala编译器从scala.Predef拿到适合的隐式函数(implicit def augmentString)，把”abc”从类型java.lang.String变成StringOps</p>

<p>于是，我们也可以自己定义隐式转化。比如下面程序中convertIntToOps把Int型对象转成IntOps型对象。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class IntOps(x: Int){
</span><span class='line'> def sayHi = “Hi, I am # “ + x
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>implicit def convertIntToOps(x: Int) = new IntOps(x)
</span><span class='line'>println(1.sayHi)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//以上程序打印出 Hi, I am # 1&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>可以看出隐式类型转化为Scala提供了类似动态语言的Meta-programming的能力。</p>

<h3 id="section-2">隐式参数</h3>

<p>隐式参数在 重构二 加上隐式参数 中已经说过了，这里略去重复描述。</p>

<h3 id="view-bound">View Bound</h3>

<p>在很多情况下，隐式参数和隐式类型转化被放在一起用，例如下面的例子：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Container&lt;a href="implicit conv: A =&gt; Int">A&lt;/a>{
</span><span class='line'> def addIt(x: A) = 123 + x
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>implicit def strToInt(x: String) = x.toInt&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>(new Container[String]).addIt(“123”)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>更简洁的形式是Scala提供的语法糖[A &lt;% Int], 它表示有某个隐式函数把A转化成了Int，你可以像使用Int一样使用A。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>语法糖形式 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Container[A&lt;%Int]{
</span><span class='line'> def addIt(x: A) = 123 + x
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>implicit def strToInt(x: String) = x.toInt&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>(new Container[String]).addIt(“123”)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>我们能够观察到的东西叫View，所以View Bound的意思是在某种特定的情况下(Bound: 范围)， X 可以被当做 Y使用。在语法糖形式中， A&lt;%Int, 表示类型A会被转化成Int用。</p>

<h3 id="context-bound">Context Bound</h3>

<p>implicit的另外一个用处是叫做Context Bound。Context Bound和View Bound有点不同，View Bound是把X当做Y用， 所以需要一个隐式的转化函数，就像上面的implicit def strToInt(x: String) = x.toInt。而Context Bound的意思是上下文(Context)条件下，X有一个Y。在下面代码一中，我定义一个Addable特征，同时有两个实现IntAdd和StringAdd。我把他们声明为implicit object, 目的是Container对象可以引用他们。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>代码一 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>trait Addable[T]{
</span><span class='line'> def add(x: T, y: T): T
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>implicit object IntAdd extends Addable[Int]{
</span><span class='line'> def add(x: Int, y: Int): Int = x + y
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>implicit object StringAdd extends Addable[String]{
</span><span class='line'> def add(x: String, y: String): String = x + y
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Container&lt;a href="implicit a: Addable[A]">A&lt;/a>{
</span><span class='line'> def add(x:A, y: A) = a.add(x, y)
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>(new Container[Int]).add(1, 2)                &lt;br />
</span><span class='line'>(new Container[String]).add(“a”, “b”)          &lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>更简洁的形式是Scala提供的语法糖[A: Addable], 它表示在你的函数或者对象（看你是把它定义在函数上还是类上）里有个Addable的对象供你使用。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>把Container写成语法糖形式</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//定义在类上
</span><span class='line'>class Container[A: Addable]{
</span><span class='line'>  	def add(x:A, y: A) = implicitly[Addable[A]].add(x, y)
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>(new Container[Int]).add(1, 2)
</span><span class='line'>(new Container[String]).add(“a”, “b”)&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//定义在函数上
</span><span class='line'>def add&lt;a href="x: A, y: A">A: Addable&lt;/a> = implicitly[Addable[A]].add(x, y)
</span><span class='line'>add(“abc”, “def”) &lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>从上面的代码我们可以看到Container可以使用上下文中的Addable对象，也就是Container有一个Addable对象，就是我上面说的X has-a Y。</p>

<p>除了可以声明implicit object，我们还可以声明implicit class。通过implicit class，我们可以很容易地实现GOF的Adapter模式。在下面代码中，编译器“自动”地把LegacyUserService转化成UserServiceAdapter</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>用隐式类型实现一个Adapter 模式</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>trait UserService{
</span><span class='line'> def getUserRole(userId: String) : String
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class LegacyUserService{
</span><span class='line'> def getUserRoleByUserId(userId: String) : String = {
</span><span class='line'>	userId.toUpperCase()(0) + “ Role”
</span><span class='line'> }
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>implicit class UserServiceAdapter(legacyUserService : LegacyUserService) extends UserService{
</span><span class='line'> def getUserRole(userId: String) = {
</span><span class='line'>	legacyUserService.getUserRoleByUserId(userId)
</span><span class='line'> }
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>val userService: UserService = new LegacyUserService()&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>println(userService.getUserRole(“alex”)) &lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这篇文章的信息量有点大，这和我之前想象的不同，它也花费了我将近一个星期的下班后时间。在边写边思考的过程中，我学到了很多东西。</p>

<h4 id="section-3">参考资料</h4>

<p><a href="">http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html</a></p>

<p><a href="">http://www.scala-lang.org/api/current/index.html#scala.math.Ordering</a></p>

<p><a href="">http://www.scala-lang.org/docu/files/ScalaByExample.pdf</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 点滴 (2)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/31/scala-2/"/>
    <updated>2014-08-31T11:20:58+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/31/scala-2</id>
    <content type="html"><![CDATA[<h2 id="scala">Scala函数之初体验</h2>

<p>下面这个例子是Scala发明者Martin Odersky在Coursera上授课用的例子，这个例子在SICP(Structure and Interpretation of Computer Programs, 计算机程序的构造和解释)一书中也有。我这里重述这个例子的原因是这个例子即包含数学思想又包含Scala语法，它即实用又有趣。</p>

<p>它就是，</p>

<h3 id="sqrt2">通过牛顿法求$\sqrt{2}$的近似值</h3>

<p>从这篇维基百科<a href="http://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法介绍</a> 我们可以知道，牛顿法是一种迭代方法。所谓迭代的意思是上一次计算的结果都对本次计算起作用，换句话说，上次计算得出的结果可以作为本次计算的输入。</p>

<p>本文主要讲述如果用Scala实现牛顿法，所以牛顿法的分析过程就此略过，而直接给出公式：</p>

<script type="math/tex; mode=display">x_{n+1} = x_n - \frac{f(x_n)}{f'(x_{n})}</script>

<p>而$\sqrt{2}$就是$f(x) = x^2 - 2 = 0$的根，根据上面的公式通过求得</p>

<script type="math/tex; mode=display">x_{n+1} = \frac{x_n + \frac{2}{x_n}}{2}</script>

<p>现在只要给出一个初始值$x_0$就可以通过上面的迭代公式求出结果。因为$f(x) = x^2 - 2 = 0$，所以$x^2=2$，易知1&lt;x&lt;2。因此，我们可以给出一个初始值$x_0 = 1 $ 。</p>

<p>一切准备工作就绪，我可以编程了…</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class='line'>def abs(x: Double) = if(x &gt;=0) x else -x&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class='line'>def isGoodEnough(guess: Double) = 
</span><span class='line'>	abs(guess * guess - 2) &lt; 0.000001&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//这个就是迭代公式
</span><span class='line'>def improve(guess: Double) = (guess + 2/guess) / 2&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//迭代函数,迭代函数必须有返回值类型
</span><span class='line'>def iter(guess: Double):Double = {
</span><span class='line'>	if (isGoodEnough(guess)) guess
</span><span class='line'>	else iter(improve(guess))
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//求根函数, 传入迭代的初始值 1
</span><span class='line'>def sqrt2 = iter(1)     &lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>学过编程的人都会觉得上面的程序好傻。首先，这个sqrt2只能够求$\sqrt{2}$的值，它不能求$\sqrt{3} , \sqrt{5} …$, 其次isGoodEnough函数的精度不能写死了，总之不够灵活(flexible)。</p>

<p>所以，我进行第一次重构…</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>第一次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>val precision = 0.000001&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class='line'>def abs(x: Double) = if(x &gt;=0) x else -x&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class='line'>def isGoodEnough(guess: Double, x: Double) = 
</span><span class='line'>	abs(guess * guess - x) &lt; precision&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//这个就是迭代公式
</span><span class='line'>def improve(guess: Double, x: Double) = (guess + x/guess) / 2&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//迭代函数,迭代函数必须有返回值类型
</span><span class='line'>def iter(guess: Double, x: Double):Double = {
</span><span class='line'>	if (isGoodEnough(guess, x)) guess
</span><span class='line'>	else iter(improve(guess, x), x)
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//求根函数, 传入迭代的初始值 1
</span><span class='line'>def sqrt(x: Double) = iter(1, x)&lt;br /></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>经过一次重构，程序比第一次好些了，但是还有个问题：因为isGoodEnough, improve, iter这些函数都是sqrt函数计算的一部分，能不能把它们封装到函数sqrt里面呢？ 答案是可以的，这也正是Scala的一个优点（相对于Java）。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>第二次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>//求根函数, 传入迭代的初始值 1
</span><span class='line'>def sqrt(x: Double)  = {
</span><span class='line'>	val precision = 0.000001&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class='line'>def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class='line'>
</span><span class='line'>//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class='line'>def isGoodEnough(guess: Double, x: Double) = 
</span><span class='line'>	abs(guess * guess - x) &lt; precision
</span><span class='line'>
</span><span class='line'>//这个就是迭代公式
</span><span class='line'>def improve(guess: Double, x: Double) = (guess + x/guess) / 2
</span><span class='line'>
</span><span class='line'>//迭代函数,迭代函数必须有返回值类型
</span><span class='line'>def iter(guess: Double, x: Double):Double = {
</span><span class='line'>	if (isGoodEnough(guess, x)) guess
</span><span class='line'>	else iter(improve(guess, x), x)
</span><span class='line'>}	
</span><span class='line'>
</span><span class='line'>iter(1, x) }</span></code></pre></td></tr></table></div></figure></notextile></div>
</code></pre>

<p>通过上述函数sqrt算出$\sqrt{2} = 1.4142135623746899 , \sqrt{3} = 1.7320508100147274$</p>

<p>至此，假如你刚学Scala，我相信这个例子能给一些Scala函数的初步印象，比如函数的形式，再比如函数里面嵌套函数，但这绝对不是Scala函数的全貌。要知道函数在Scala里可是first-class citizen (头等公民)，关于这点我在后续文章里会有分享。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 点滴 (1)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/31/scala-1/"/>
    <updated>2014-08-31T11:06:48+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/31/scala-1</id>
    <content type="html"><![CDATA[<p>在Coursera上学习Scala编程有两个月了， Scala的基础课程即将结束。在新的课程《响应式编程》开始之前，我想总结一下。</p>

<h2 id="section">编程范式</h2>

<p>如果我们把现在的编程范式做下分类，我们可以分成3类：</p>

<blockquote>
  <ol>
    <li>指令编程范式</li>
    <li>函数编程范式</li>
    <li>逻辑编程范式</li>
  </ol>
</blockquote>

<p>而以上每种编程范式都与面向对象编程范式正交，意思是说指令型编程语言可以拥有面向对象特征，同理其他两种编程范式都可以拥有面向对象的特征。</p>

<p>所谓指令型编程语言范式是从冯. 诺依曼的计算机模型引申而来的，它的特点正如冯.诺依曼模型一样，运行时通过总线把它把指令和数据从内存加载到CPU，然后把结果又送回去。
更具体地说，指令编程范式对于于冯.诺依曼计算机模型有一种对应关系，</p>

<blockquote>
  <ol>
    <li>变量 相对于 内存单元</li>
    <li>释放变量  相对于 load 指令</li>
    <li>变量赋值  相对于 store 指令  </li>
    <li>分支控制  相对于 jump 指令</li>
  </ol>
</blockquote>

<p>在严格定义下，函数式编程范式则有以下特点</p>

<blockquote>
  <ol>
    <li>没有变量，也就没有对变量赋值</li>
    <li>没有指令编程范式的控制结构，例如while，loop等等</li>
    <li>函数是函数式编程范式里的头等公民，这意味着函数，就像普通值一样，可以在任何地方定义，包括在其他函数里面；此外，函数也像普通值一样，可以作为参数传到其他函数里，或作为结果返回，当然我们也可以对函数定义一下操作符用于把函数组合起来。</li>
  </ol>
</blockquote>

<p>假如我宽泛地给函数式编程范式给个定义，我们可以说，函数式编程范式主要是一种关注函数的编程范式。</p>

<p>至于逻辑编程范式，由于Martin Ordersky并没有给出解释，所以这里也略过。</p>

<p>在市面上的流行语言中，如果根据以上编程范式分类，函数式编程语言看起来应该像这样子</p>

<ol>
  <li>
    <p>严格定义下的函数式编程语言</p>

    <blockquote>
      <p>Pure Lisp, XSLT, XPath, XQuery, FP
 Haskell (without I/O Monad or UnsafePerformIO)</p>
    </blockquote>
  </li>
  <li>
    <p>广义定义下的函数式编程语言</p>

    <blockquote>
      <p>Lisp, Scheme, Racket, Clojure
SML, Ocaml, F#
Haskell (full language)
Scala
Smalltalk, Ruby (!)</p>
    </blockquote>
  </li>
</ol>
]]></content>
  </entry>
  
</feed>
