<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[观察 记录 思考]]></title>
  <link href="http://candochen.github.io/atom.xml" rel="self"/>
  <link href="http://candochen.github.io/"/>
  <updated>2014-10-16T12:26:04+08:00</updated>
  <id>http://candochen.github.io/</id>
  <author>
    <name><![CDATA[Cando]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数学常数中的e是什么]]></title>
    <link href="http://candochen.github.io/blog/2014/10/14/what-is-e/"/>
    <updated>2014-10-14T13:11:52+08:00</updated>
    <id>http://candochen.github.io/blog/2014/10/14/what-is-e</id>
    <content type="html"><![CDATA[<p>e是个很重要的数学常数，但是假如你在网上找e的定义，它会告诉你e是自然对数的底，然后你查什么是自然对数，它告诉你，自然对数是以e为底的对数。这就陷入了一个死循环,它就是始终不告诉你e是什么。我被这个问题困扰很久，直到最近看了这篇博客http://www.ruanyifeng.com/blog/2011/07/mathematical_constant_e.html 才稍微有些理解。但是，这篇博客并没有更深入地把e作为自然对数的底的原因讲到，所以顺着自己的好奇心，我看了几本关于数学的书，这才解了我心中的谜团。在这些书中 《e的故事，一个常数的传奇》以及《什么是数学，对思想和方法的基本研究》对这篇文章贡献最大，这篇文章的思路是这两本书给的。</p>

<h2 id="e-">e 是什么</h2>

<p>先说利息是什么。简单来说利息就是钱生的钱。假如你存1万块钱到银行，银行给你的年利率是100%（这是假设的，别做梦了），那么一年之后你拿到的钱是2万，可以根据这个公式算得 </p>

<script type="math/tex; mode=display">本金*(1+100\%)^1=2</script>

<p>现在你可能要想一年计息一次，我可以拿到2万，假如计息两次呢？于是你跟银行说，我要一年计息两次，银行说好吧，一年的利息是100%，那么半年的利息是50%，一年计息2次，你可以得</p>

<script type="math/tex; mode=display">本金*(1+\frac{1}{2})^2=2.25</script>

<p>你感觉到赚了，于是继续提要求，一年计息4次，银行说好吧，一年的利息是100%，那么一季度的利息是25%，一年计息4次，你可以得到</p>

<script type="math/tex; mode=display">本金*(1+\frac{1}{2})^4=2.44</script>

<p>这次你感觉赚了，但是增长少了，上次增长2.25-2 = 0.25，这次增长2.44 - 2.25 = 0.21。你在想假如我一年计息12次，365次，甚至每秒都计息，一年以后你会得到多少钱呢？你发现多计息一次，你就多赚一点，但是赚到的比上次少了点，你想假如无限次计息, 那么一年之后最多你能拿到多少钱呢？是否无无限多呢，还是存在某个极限？</p>

<p>也就是这个式子<script type="math/tex">(1 + \frac{1}{n})^n</script>, 在n趋向无穷大的时候是否存在极限。答案是会的，这个极限就是e, 它是个无理数，近似值是2.718281828。</p>

<p>所以一年之后，即使是无限次计息，你一年也只能拿到 </p>

<script type="math/tex; mode=display">本金*e \approx 2.718281828</script>

<h2 id="e">e的无穷级数的形式</h2>
<p>所以我们知道 <script type="math/tex"> e = \lim_{n\to\infty}(1 + \frac{1}{n})^n </script>, 我们把式子写成 <script type="math/tex">e= \lim_{n\to\infty}(\frac{1}{n} + 1)^n</script>, 并通过二项式将其展开</p>

<p>$(\frac{1}{n} + 1) ^n = \binom{n}{0}\frac{1}{n}^0  1^n + \binom{n}{1}\frac{1}{n}^1  1^{n-1} + … \binom{n}{1}\frac{1}{n}^n  1^0$</p>

<p>当<script type="math/tex">n\to\infty</script>，<script type="math/tex">e = \sum_{n=0}^{\infty}\frac{1}{n!}</script>, 也可以更明了地写成 </p>

<script type="math/tex; mode=display"> e = \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \frac{1}{3!} + ... </script>

<p>这个级数是牛顿在1769年发现的。</p>

<h2 id="e-1">e的近似解</h2>

<p>知道了e的无穷级数形式，我们可以通过程序计算出它的近似值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def factorial(n: Int) : Int = {
</span><span class="line">    def factIter(n: Int, accu: Int) : Int = {
</span><span class="line">         if (n==0) accu
</span><span class="line">         else if(n==1) accu
</span><span class="line">         else factIter(n-1, accu * n)
</span><span class="line">     }
</span><span class="line">    factIter(n, 1)
</span><span class="line">  } 
</span><span class="line"> 
</span><span class="line">  def numerator(n: Int) :Int ={
</span><span class="line">       (0 to n).map(factorial(n) / factorial(_)).sum
</span><span class="line">  }
</span><span class="line"> 
</span><span class="line">  numerator(12).toDouble / factorial(12)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面程序算出的结果是，2.7182818282861687</p>

<p>有通过改进牛顿无穷级数公式，通过6个项相加就可能得到近似值2.718281828
http://www.intmath.com/exponential-logarithmic-functions/calculating-e.php
http://www.brotherstechnology.com/docs/icnsae_%28cmj0104-300dpi%29.pdf</p>

<h2 id="lnx">ln(x)是什么</h2>

<p>数学不是按照教科书上的顺序发展的，其中积分的发明比微分早就是一个例子。这其中的原因可能是相对于一个曲线的斜率，人们更关心的是某个闭合曲线的面积吧。微积分发明以后人们知道假如面积可由函数F(x)表示，那么F(x)的导数恰好就曲线的函数。所以为了求闭合曲线下的面积，我们要找到曲线函数的原函数。对于函数<script type="math/tex">f(x)=x^n</script>，我们可以得到它的原函数为<script type="math/tex">F(x) = \frac{1}{n + 1} x ^{n+1}</script>，其中n对于任意有理数和无理数都成立。但是有个例外，就是n=-1，因为当n=-1的时候 <script type="math/tex">\frac{1}{n+1}</script>不存在。那么$x^{-1}$的原函数是什么呢？我们现在根据以下两个线索找找,</p>

<ol>
  <li>
    <p>在17世纪的时候有个叫圣 . 文森特的人发现了双曲线$y=x^{-1}$下投影的面积符合对数规律。</p>
  </li>
  <li>
    <p>根据对数的性质，对数的值为0的时候，对数的根是1。所以我们要求的这个对数函数，当x=1是值为0，并且x增大时趋向无穷大（看看下面的图就明白了），这就必然存在一个大于1的数，使得当这个对数函数x等于这个值的时候，F(x)= 1，我们暂时称这个数为a。
<img class="left" src="http://candochen.github.io/images/20141016/clipboard.png" width="350" height="350" title="image" alt="images" />
知道了这两个重要信息，我们想知道这个a到底是怎样一个数? 那么假设<script type="math/tex">x^{-1}</script>在1到<script type="math/tex">\infty</script>的积分的原函数是A(x), 根据导数的定义 </p>
  </li>
</ol>

<script type="math/tex; mode=display">A'(x) = \frac{A(x+h) - A(x)}{h} = \frac{1}{x}</script>

<script type="math/tex; mode=display">A'(x) = \frac{A(x+h) - A(x)}{h} = A(1 + \frac{h}{x}) = \frac{1}{x}</script>

<p>用<script type="math/tex">\frac{1}{n}, n\to\infty</script>来代替h，我们得到</p>

<script type="math/tex; mode=display">A'(x) = A(1+\frac{1}{nx}) * n = \frac{1}{x}</script>

<p>根据对数性质外面的n可以移到函数里面变成</p>

<script type="math/tex; mode=display">A'(x) = A((1+\frac{1}{nx})^n) = \frac{1}{x}</script>

<p>令x = 1 等式右边为1，等式左边括号里的东西就是<script type="math/tex"> e = \lim_{n\to\infty}(1 + \frac{1}{n})^n </script>,  原来我们要找的这个数就是e</p>

<p>由于A(x）是对数函数那么它的形式是$\log_a(x)$, 由于$\log_a(e) = 1$，所以a= e, 也就是以e为底的对数，也称自然对数，记为ln。 它的函数式ln(x), 它是曲线从1到x的积分， 即$\int_1^x \frac{1}{u}\,du$。</p>

<h2 id="ex-">$e^x$ 是什么</h2>
<p>$e^x$是ln(x)的反函数，它是指数函数。我们知道指数函数有这样的性质：</p>

<p>性质1 f(x+y) = f(x)*f(y)</p>

<p>性质2 f(xy) = f(x)^y</p>

<p>根据导数的定义，对指数函数求导</p>

<script type="math/tex; mode=display">f'(x) = \frac{f(x+h) - f(x)}{h}, h\to 0</script>

<p>应用性质1</p>

<script type="math/tex; mode=display">f'(x) = f(x) * \frac{f(h) - 1}{h}, h\to 0</script>

<p>所以我们可以看出指数函数的导数和它自身存在倍数关系，在什么情况先指数函数跟它自身相等呢？从上面式子可以看出，假如$\frac{f(h) - 1}{h} = 1, h\to 0$, 那么该指数函数的导数就和自身相等了。</p>

<p>针对$\frac{f(h) - 1}{h} = 1, h\to 0$, 令$h = \frac{1}{n}, n\to\infty$</p>

<script type="math/tex; mode=display">\frac{f(\frac{1}{n}) - 1}{\frac{1}{n}} = 1, n\to\infty</script>

<script type="math/tex; mode=display">f(\frac{1}{n}) - 1 = n, n\to\infty</script>

<script type="math/tex; mode=display">f(\frac{1}{n}) = n + 1, n\to\infty</script>

<script type="math/tex; mode=display">f(1)^\frac{1}{n} = n + 1, n\to\infty</script>

<script type="math/tex; mode=display">f(1) = (n + 1)^n, n\to\infty</script>

<p>可以看出等式右边就是e，所以当指数函数是以e为底的指数函数式它的导数等于自身。</p>

<blockquote>
  <p>自然指数函数与它的导数相等。这是指数函数所有特征的本源，也是它得到重要应用的根本原因。–柯朗和罗宾斯《什么是数学》1941</p>
</blockquote>

<p>另外，针对$\lim_{n\to\infty}(1 + \frac{1}{nx})^n$ 做二项式展开，得</p>

<script type="math/tex; mode=display">\frac{1}{0!} + \frac{x}{1!} + \frac{x^2}{2!} + \frac{x^3}{3!} + ... </script>

<p>对以上无穷级数的每项对x求导，结果还是</p>

<script type="math/tex; mode=display">\frac{1}{0!} + \frac{x}{1!} + \frac{x^2}{2!} + \frac{x^3}{3!} + ... </script>

<p>所以</p>

<script type="math/tex; mode=display">e^x = \frac{1}{0!} + \frac{x}{1!} + \frac{x^2}{2!} + \frac{x^3}{3!} + ... </script>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 点滴 (3)]]></title>
    <link href="http://candochen.github.io/blog/2014/09/03/scala-3/"/>
    <updated>2014-09-03T19:06:04+08:00</updated>
    <id>http://candochen.github.io/blog/2014/09/03/scala-3</id>
    <content type="html"><![CDATA[<h3 id="section">隐式参数和隐式类型转化</h3>

<p>我想通过一个快速排序的例子，分享我对Scala中隐式参数和隐式类型转换的理解。相对于指令型语言，用Scala实现一个快速排序即简单又容易理解（代码容易阅读）。在开始之前，我想简单描述一下快速排序的思想。</p>

<p>假设我们有个无序的整数型列表，为了简单起见，它仅仅包含的5个数字分别是: 3, 4, 5, 2, 1。为了体现每个数字在排序过程中位置的变化，我把每个数字都加上下标，比如这样$3_1, 5_2, 4_3, 2_4, 1_5$。</p>

<p>让我们来看看每次排序都发生什么样的变化。</p>

<p>初始状态下
<script type="math/tex">3_1, 5_2, 4_3, 2_4, 1_5</script></p>

<p>我们现在随便选择一个数，在本例中我们选择第一个数3，然后把小于或者等于这个数的所有的数放到这个数的左边，把大于这个数的所有的数放到这个数的右边。
于是这个列表变成，
<script type="math/tex">2_1, 1_2, 3_3, 5_4, 4_5</script></p>

<p>可以看出我们选择的这个数3处于在最终应该处的位置。在上一步中，我们实际做了3件事</p>

<ol>
  <li>选一个数 （这个数叫Pivot）</li>
  <li>把小于或者等于Pivot的数放到Pivot的左边，把大于Pivot的数放到Pivot的右边 </li>
  <li>最后把这3部分合并，为了看清楚一点，我把这3部分用括号括起来</li>
</ol>

<script type="math/tex; mode=display">(2_1, 1_2) (3_3) (5_4, 4_5)</script>

<p>现在可以看出不论Pivot左边还是右边都是没有排序的，所以我们只要分别针对左边列表和右边列表重复进行以上步骤就可以了，显然这是个递归过程。（上述算法在最优条件下的时间复杂度是O(nlgn), 在最坏情况下的时间复杂度是$O(n^2)$, 可以通过随机化算法随机选择Pivot,这时候它的时间复杂度是O(nlgn), 关于这点我再这里就不多说了）</p>

<p>一切准备就绪，来看看Scala是如何简单实现快速排序的吧</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>最初的快速排序函数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def quickSort(xs: List[Int]): List[Int] = xs match {
</span><span class="line"> case Nil =&gt; Nil
</span><span class="line"> case x::xs =&gt; {
</span><span class="line">	val left = xs.filter(_&lt;=x)
</span><span class="line">	val right = xs.filter(_&gt;x)
</span><span class="line">	quickSort(left) ::: List(x) ::: quickSort(right)
</span><span class="line"> }
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上述程序可以对Int型对象进行排序，能不能让它对任意的对象都可以排序呢？仔细观察一下，可以发现不同对象的比较运算符可能不一样，对于Int的对象，我们能用运算符&gt;= 或&lt; 来比较两个Int对象的大小，但是对于其他对象比较的运算符就不确定了。为了使得函数能够比较更多类型，可以增加一个比较函数作为参数传进去，于是函数变成这样</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>重构一 加上泛型和比较函数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def quickSort[T](xs: List[Int])(lt: (T, T)=&gt; Boolean): List[T] = xs match {
</span><span class="line"> case Nil =&gt; Nil
</span><span class="line"> case x::xs =&gt; {
</span><span class="line">  val left = xs.filter(lt(_,x))
</span><span class="line">  val right = xs.filter(!lt(_,x))
</span><span class="line">  quickSort(left)(lt) ::: List(x) ::: quickSort(right)(lt)
</span><span class="line"> }
</span><span class="line">}
</span><span class="line">
</span><span class="line">//测试一下
</span><span class="line">def strLt(s1 : String, s2: String) = if (s1.compareTo(s2) &lt;=0) true else false
</span><span class="line">
</span><span class="line">val testList = List("scala","is", "fantastic")
</span><span class="line">
</span><span class="line">quickSort(testList)(strLt)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>重构之后, quickSort函数能够对包含任何对象的列表进行排序。但是改进仍在继续，我们可以通过定义隐式参数把第二参数也去掉。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>重构二 加上隐式参数 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">def quickSort[T](xs: List[Int])(implicit lt: (T, T)=&gt; Boolean): List[T] = xs match {
</span><span class="line"> case Nil =&gt; Nil
</span><span class="line"> case x::xs =&gt; {
</span><span class="line">  val left = xs.filter(lt(_,x))
</span><span class="line">  val right = xs.filter(!lt(_,x))
</span><span class="line">  quickSort(left)(lt) ::: List(x) ::: quickSort(right)(lt)
</span><span class="line"> }
</span><span class="line">}
</span><span class="line">
</span><span class="line">//测试一下
</span><span class="line">implicit def strLt(s1 : String, s2: String) = if (s1.compareTo(s2) &lt;=0) true else false
</span><span class="line">
</span><span class="line">val testList = List("scala","is", "fantastic")
</span><span class="line">
</span><span class="line">quickSort(testList)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>很神奇，对吧？ 那么隐式参数是怎么工作的呢？这要归功于Scala强大的编译器。在Scala中，隐式（implicit）意味着一个值（函数也是值-value）能够自动地传入函数中，或者一个类型的对象能够自动转化成另外一个类型的对象。具体来说implicit在Scala中有下面4种含义。</p>

<h3 id="section-1">隐式转化</h3>

<p>简单来说，如果一个函数调用一个类型为c的对象o的方法m, 这时候发现这个o对象没有方法m, 那么Scala编译器会找到一个隐式类型转化函数，把对象o从c变成另外一个有m方法的类型的对象。</p>

<p>比如 “abc”.map(_.toInt), 我们知道String类型是没有map方法的，这时Scala编译器从scala.Predef拿到适合的隐式函数(implicit def augmentString)，把”abc”从类型java.lang.String变成StringOps</p>

<p>于是，我们也可以自己定义隐式转化。比如下面程序中convertIntToOps把Int型对象转成IntOps型对象。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class IntOps(x: Int){
</span><span class="line"> def sayHi = "Hi, I am # " + x
</span><span class="line">}
</span><span class="line">
</span><span class="line">implicit def convertIntToOps(x: Int) = new IntOps(x)
</span><span class="line">println(1.sayHi)
</span><span class="line">
</span><span class="line">//以上程序打印出 Hi, I am # 1</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>可以看出隐式类型转化为Scala提供了类似动态语言的Meta-programming的能力。</p>

<h3 id="section-2">隐式参数</h3>

<p>隐式参数在 重构二 加上隐式参数 中已经说过了，这里略去重复描述。</p>

<h3 id="view-bound">View Bound</h3>

<p>在很多情况下，隐式参数和隐式类型转化被放在一起用，例如下面的例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class Container[A](implicit conv: A =&gt; Int){
</span><span class="line"> def addIt(x: A) = 123 + x
</span><span class="line">}
</span><span class="line">
</span><span class="line">implicit def strToInt(x: String) = x.toInt
</span><span class="line">
</span><span class="line">(new Container[String]).addIt("123")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更简洁的形式是Scala提供的语法糖[A &lt;% Int], 它表示有某个隐式函数把A转化成了Int，你可以像使用Int一样使用A。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>语法糖形式 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class Container[A&lt;%Int]{
</span><span class="line"> def addIt(x: A) = 123 + x
</span><span class="line">}
</span><span class="line">
</span><span class="line">implicit def strToInt(x: String) = x.toInt
</span><span class="line">
</span><span class="line">(new Container[String]).addIt("123")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们能够观察到的东西叫View，所以View Bound的意思是在某种特定的情况下(Bound: 范围)， X 可以被当做 Y使用。在语法糖形式中， A&lt;%Int, 表示类型A会被转化成Int用。</p>

<h3 id="context-bound">Context Bound</h3>

<p>implicit的另外一个用处是叫做Context Bound。Context Bound和View Bound有点不同，View Bound是把X当做Y用， 所以需要一个隐式的转化函数，就像上面的implicit def strToInt(x: String) = x.toInt。而Context Bound的意思是上下文(Context)条件下，X有一个Y。在下面代码一中，我定义一个Addable特征，同时有两个实现IntAdd和StringAdd。我把他们声明为implicit object, 目的是Container对象可以引用他们。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>代码一 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class=""><span class="line">trait Addable[T]{
</span><span class="line"> def add(x: T, y: T): T
</span><span class="line">}
</span><span class="line">  
</span><span class="line">implicit object IntAdd extends Addable[Int]{
</span><span class="line"> def add(x: Int, y: Int): Int = x + y
</span><span class="line">}
</span><span class="line">  
</span><span class="line">  
</span><span class="line">implicit object StringAdd extends Addable[String]{
</span><span class="line"> def add(x: String, y: String): String = x + y
</span><span class="line">}
</span><span class="line">  
</span><span class="line">class Container[A](implicit a: Addable[A]){
</span><span class="line"> def add(x:A, y: A) = a.add(x, y)
</span><span class="line">}
</span><span class="line">  
</span><span class="line">(new Container[Int]).add(1, 2)                  
</span><span class="line">(new Container[String]).add("a", "b")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更简洁的形式是Scala提供的语法糖[A: Addable], 它表示在你的函数或者对象（看你是把它定义在函数上还是类上）里有个Addable的对象供你使用。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>把Container写成语法糖形式</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//定义在类上
</span><span class="line">class Container[A: Addable]{
</span><span class="line">  	def add(x:A, y: A) = implicitly[Addable[A]].add(x, y)
</span><span class="line">}
</span><span class="line">  
</span><span class="line">(new Container[Int]).add(1, 2)
</span><span class="line">(new Container[String]).add("a", "b")
</span><span class="line">
</span><span class="line">//定义在函数上
</span><span class="line">def add[A: Addable](x: A, y: A) = implicitly[Addable[A]].add(x, y)
</span><span class="line">add("abc", "def")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>从上面的代码我们可以看到Container可以使用上下文中的Addable对象，也就是Container有一个Addable对象，就是我上面说的X has-a Y。</p>

<p>除了可以声明implicit object，我们还可以声明implicit class。通过implicit class，我们可以很容易地实现GOF的Adapter模式。在下面代码中，编译器“自动”地把LegacyUserService转化成UserServiceAdapter</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>用隐式类型实现一个Adapter 模式</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">trait UserService{
</span><span class="line"> def getUserRole(userId: String) : String
</span><span class="line">}
</span><span class="line">  
</span><span class="line">  
</span><span class="line">class LegacyUserService{
</span><span class="line"> def getUserRoleByUserId(userId: String) : String = {
</span><span class="line">	userId.toUpperCase()(0) + " Role"
</span><span class="line"> }
</span><span class="line">}
</span><span class="line">  
</span><span class="line">  
</span><span class="line">implicit class UserServiceAdapter(legacyUserService : LegacyUserService) extends UserService{
</span><span class="line"> def getUserRole(userId: String) = {
</span><span class="line">	legacyUserService.getUserRoleByUserId(userId)
</span><span class="line"> }
</span><span class="line">}
</span><span class="line">
</span><span class="line"> 
</span><span class="line">val userService: UserService = new LegacyUserService()
</span><span class="line">                                                   	
</span><span class="line">println(userService.getUserRole("alex"))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这篇文章的信息量有点大，这和我之前想象的不同，它也花费了我将近一个星期的下班后时间。在边写边思考的过程中，我学到了很多东西。</p>

<h4 id="section-3">参考资料</h4>

<p><a href="">http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html</a></p>

<p><a href="">http://www.scala-lang.org/api/current/index.html#scala.math.Ordering</a></p>

<p><a href="">http://www.scala-lang.org/docu/files/ScalaByExample.pdf</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何学习 (4)]]></title>
    <link href="http://candochen.github.io/blog/2014/09/01/learning-how-to-learn-4/"/>
    <updated>2014-09-01T09:26:39+08:00</updated>
    <id>http://candochen.github.io/blog/2014/09/01/learning-how-to-learn-4</id>
    <content type="html"><![CDATA[<h2 id="section">睡眠很重要</h2>

<p>你在清醒中学习的时候你的大脑会分泌出毒素。那你的大脑是如何排出这些毒素的呢？答案就是：睡觉。</p>

<p>当你睡觉的时候，你的脑细胞就会收缩</p>

<blockquote>
  <p>Turns out that when you sleep, your brain cells shrink.</p>
</blockquote>

<p>因此细胞之间的空隙就会增大。这就像是打开了一个水龙头，流体流过大脑细胞间隙的时候，也就把毒素给排出去了。</p>

<blockquote>
  <p>Fluid can flow past these cells and wash the toxins out.</p>
</blockquote>

<p>有时候你可能会觉得睡觉挺浪费时间的，但是这是有回报的：你的大脑更加干净和健康。</p>

<p>实际上，缺乏睡眠不仅对你的大脑健康造成损害，而且对你的健康还造成影响，比如会导致心脏病，头疼，抑郁，等等。</p>

<p>当然过多的睡眠跟过少的睡眠是一样的。</p>

<p>充足的睡眠除了对你的健康有益外，对你的学习也大有裨益。</p>

<blockquote>
  <p>Sleep has also been shown to make a remarkable difference in your ability to figure out difficult problems and to understand what you’re trying to learn.</p>
</blockquote>

<p>在你睡觉的时候，负责你意识清醒的大脑前额皮质会松弛下来，这给激活大脑其他的区域创造了机会。于是这些在你睡觉的时候依然工作的大脑各个区域组成解决你学习任务的神经系统。</p>

<p>在你打盹或者睡觉之前，如果你集中精力思考一个问题，你可能会梦到你所思考的问题。而梦到你所思考的问题还会增加你理解问题的能力。</p>

<p>所以充足的睡眠是你学习的一部分，不要再觉得睡觉浪费时间了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 点滴 (2)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/31/scala-2/"/>
    <updated>2014-08-31T11:20:58+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/31/scala-2</id>
    <content type="html"><![CDATA[<h2 id="scala">Scala函数之初体验</h2>

<p>下面这个例子是Scala发明者Martin Odersky在Coursera上授课用的例子，这个例子在SICP(Structure and Interpretation of Computer Programs, 计算机程序的构造和解释)一书中也有。我这里重述这个例子的原因是这个例子即包含数学思想又包含Scala语法，它即实用又有趣。</p>

<p>它就是，</p>

<h3 id="sqrt2">通过牛顿法求$\sqrt{2}$的近似值</h3>

<p>从这篇维基百科<a href="http://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿法介绍</a> 我们可以知道，牛顿法是一种迭代方法。所谓迭代的意思是上一次计算的结果都对本次计算起作用，换句话说，上次计算得出的结果可以作为本次计算的输入。</p>

<p>本文主要讲述如果用Scala实现牛顿法，所以牛顿法的分析过程就此略过，而直接给出公式：</p>

<script type="math/tex; mode=display">x_{n+1} = x_n - \frac{f(x_n)}{f'(x_{n})}</script>

<p>而$\sqrt{2}$就是$f(x) = x^2 - 2 = 0$的根，根据上面的公式通过求得</p>

<script type="math/tex; mode=display">x_{n+1} = \frac{x_n + \frac{2}{x_n}}{2}</script>

<p>现在只要给出一个初始值$x_0$就可以通过上面的迭代公式求出结果。因为$f(x) = x^2 - 2 = 0$，所以$x^2=2$，易知1&lt;x&lt;2。因此，我们可以给出一个初始值$x_0 = 1 $ 。</p>

<p>一切准备工作就绪，我可以编程了…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">def isGoodEnough(guess: Double) = 
</span><span class="line">	abs(guess * guess - 2) &lt; 0.000001
</span><span class="line">
</span><span class="line">//这个就是迭代公式
</span><span class="line">def improve(guess: Double) = (guess + 2/guess) / 2
</span><span class="line">
</span><span class="line">//迭代函数,迭代函数必须有返回值类型
</span><span class="line">def iter(guess: Double):Double = {
</span><span class="line">	if (isGoodEnough(guess)) guess
</span><span class="line">	else iter(improve(guess))
</span><span class="line">}
</span><span class="line">
</span><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt2 = iter(1)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>学过编程的人都会觉得上面的程序好傻。首先，这个sqrt2只能够求$\sqrt{2}$的值，它不能求$\sqrt{3} , \sqrt{5} …$, 其次isGoodEnough函数的精度不能写死了，总之不够灵活(flexible)。</p>

<p>所以，我进行第一次重构…</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>第一次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class=""><span class="line">val precision = 0.000001
</span><span class="line">
</span><span class="line">//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">def isGoodEnough(guess: Double, x: Double) = 
</span><span class="line">	abs(guess * guess - x) &lt; precision
</span><span class="line">
</span><span class="line">//这个就是迭代公式
</span><span class="line">def improve(guess: Double, x: Double) = (guess + x/guess) / 2
</span><span class="line">
</span><span class="line">//迭代函数,迭代函数必须有返回值类型
</span><span class="line">def iter(guess: Double, x: Double):Double = {
</span><span class="line">	if (isGoodEnough(guess, x)) guess
</span><span class="line">	else iter(improve(guess, x), x)
</span><span class="line">}
</span><span class="line">
</span><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt(x: Double) = iter(1, x)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>经过一次重构，程序比第一次好些了，但是还有个问题：因为isGoodEnough, improve, iter这些函数都是sqrt函数计算的一部分，能不能把它们封装到函数sqrt里面呢？ 答案是可以的，这也正是Scala的一个优点（相对于Java）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>第二次重构 </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">//求根函数, 传入迭代的初始值 1
</span><span class="line">def sqrt(x: Double)  = {
</span><span class="line">	val precision = 0.000001
</span><span class="line">	
</span><span class="line">	//首先我需要一个求绝对值的函数（虽然Scala的标准库中有这个函数，这里为了描述的完整性，先不考虑它)
</span><span class="line">	def abs(x: Double) = if(x &gt;=0) x else -x
</span><span class="line">	
</span><span class="line">	//然后“猜”一值，这个值原先是初始值, 之后是每次迭代得到的新结果
</span><span class="line">	def isGoodEnough(guess: Double, x: Double) = 
</span><span class="line">		abs(guess * guess - x) &lt; precision
</span><span class="line">
</span><span class="line">	//这个就是迭代公式
</span><span class="line">	def improve(guess: Double, x: Double) = (guess + x/guess) / 2
</span><span class="line">
</span><span class="line">	//迭代函数,迭代函数必须有返回值类型
</span><span class="line">	def iter(guess: Double, x: Double):Double = {
</span><span class="line">		if (isGoodEnough(guess, x)) guess
</span><span class="line">		else iter(improve(guess, x), x)
</span><span class="line">	}	
</span><span class="line">	
</span><span class="line">	iter(1, x)
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过上述函数sqrt算出$\sqrt{2} = 1.4142135623746899 , \sqrt{3} = 1.7320508100147274$</p>

<p>至此，假如你刚学Scala，我相信这个例子能给一些Scala函数的初步印象，比如函数的形式，再比如函数里面嵌套函数，但这绝对不是Scala函数的全貌。要知道函数在Scala里可是first-class citizen (头等公民)，关于这点我在后续文章里会有分享。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala 点滴 (1)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/31/scala-1/"/>
    <updated>2014-08-31T11:06:48+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/31/scala-1</id>
    <content type="html"><![CDATA[<p>在Coursera上学习Scala编程有两个月了， Scala的基础课程即将结束。在新的课程《响应式编程》开始之前，我想总结一下。</p>

<h2 id="section">编程范式</h2>

<p>如果我们把现在的编程范式做下分类，我们可以分成3类：</p>

<blockquote>
  <ol>
    <li>指令编程范式</li>
    <li>函数编程范式</li>
    <li>逻辑编程范式</li>
  </ol>
</blockquote>

<p>而以上每种编程范式都与面向对象编程范式正交，意思是说指令型编程语言可以拥有面向对象特征，同理其他两种编程范式都可以拥有面向对象的特征。</p>

<p>所谓指令型编程语言范式是从冯. 诺依曼的计算机模型引申而来的，它的特点正如冯.诺依曼模型一样，运行时通过总线把它把指令和数据从内存加载到CPU，然后把结果又送回去。
更具体地说，指令编程范式对于于冯.诺依曼计算机模型有一种对应关系，</p>

<blockquote>
  <ol>
    <li>变量 相对于 内存单元</li>
    <li>释放变量  相对于 load 指令</li>
    <li>变量赋值  相对于 store 指令  </li>
    <li>分支控制  相对于 jump 指令</li>
  </ol>
</blockquote>

<p>在严格定义下，函数式编程范式则有以下特点</p>

<blockquote>
  <ol>
    <li>没有变量，也就没有对变量赋值</li>
    <li>没有指令编程范式的控制结构，例如while，loop等等</li>
    <li>函数是函数式编程范式里的头等公民，这意味着函数，就像普通值一样，可以在任何地方定义，包括在其他函数里面；此外，函数也像普通值一样，可以作为参数传到其他函数里，或作为结果返回，当然我们也可以对函数定义一下操作符用于把函数组合起来。</li>
  </ol>
</blockquote>

<p>假如我宽泛地给函数式编程范式给个定义，我们可以说，函数式编程范式主要是一种关注函数的编程范式。</p>

<p>至于逻辑编程范式，由于Martin Ordersky并没有给出解释，所以这里也略过。</p>

<p>在市面上的流行语言中，如果根据以上编程范式分类，函数式编程语言看起来应该像这样子</p>

<ol>
  <li>
    <p>严格定义下的函数式编程语言</p>

    <blockquote>
      <p>Pure Lisp, XSLT, XPath, XQuery, FP
 Haskell (without I/O Monad or UnsafePerformIO)</p>
    </blockquote>
  </li>
  <li>
    <p>广义定义下的函数式编程语言</p>

    <blockquote>
      <p>Lisp, Scheme, Racket, Clojure
SML, Ocaml, F#
Haskell (full language)
Scala
Smalltalk, Ruby (!)</p>
    </blockquote>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何学习 (3)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/31/learning-how-to-learn-3/"/>
    <updated>2014-08-31T10:32:53+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/31/learning-how-to-learn-3</id>
    <content type="html"><![CDATA[<h2 id="long-term-memory-working-memory-">Long term memory Working Memory 长期记忆和工作记忆</h2>
<p>假如你要回忆童年往事或者数学公式，你用的是人脑中负责长期记忆的long term memory；假如你想把其中一些概念联系起来解决某些问题，你要的是working memory。
你有时候会把一些记忆从long term memory取出，然后放到working memory里，这时候long term memory就和working memory发生了联系。（我觉得，就这working memory 和 long term memory的关系来说，很像计算机中内存和硬盘的关系–当信息需要长期存储的时候它被放到硬盘中；当它需要被处理的时候，把它载到内存中处理。）</p>

<p>表面上来看，working memory就像一个黑盒子，但是这个盒子里面的东西是很容易模糊的，比如你要写下一串数字，你需要重复好几次才能把它记得，然后才能写下来。</p>

<p>当你学习新事物的时候，你使用working memory。</p>

<p>Long term memory非常重要，你的解决问题的技巧等等都存放在long term memory里，于是你需要往long term memory里存放信息。</p>

<p>当你第一次把某信息放入long term memory，你起码需要重复“访问”它几次，这样你才能增加下次找到它的几率。同时不同的item在long term memory里还可能会相互覆盖，这时候你需要更多的练习才可能从这相互覆盖的区域找到你想要的东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何学习 (2)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/29/learning-how-to-learn-2/"/>
    <updated>2014-08-29T20:23:11+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/29/learning-how-to-learn-2</id>
    <content type="html"><![CDATA[<h1 id="practice-makes-permanent">Practice makes permanent</h1>

<p>Bard 老师从16岁才开始真正地学习数学，在那之前她非常害怕和痛恨学习数学和科学。她没想到她后来回从事工程(engineering)的工作。刚开始的时候，她觉得数学太难了，在她看来数学对其他同学来说是那么容易–他们学得又快又准。在学习过程中，她有时候会放下学习，到外面的世界去逛逛，回来之后再继续学。她说，她不是自然就学会数学的，而是一步一步、循序渐进地学习得来的。</p>

<p>数学是抽象的，它不容易掌握，不像具体的事物，比如一头奶牛，你知道cow是奶牛的意思，你可以对着奶牛指着它，看着它学习cow。 但是数学通常情况下没有类似的东西让你比较，让你联系。当然你可以说，类似“爱”，“希望”这些词也是抽象的，但是通常这些词可以从人的情感中找到联系，但是数学概念不行。</p>

<p>正是因为数学是抽象的，我们需要不停地练习以强化数学思想。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何学习 (1)]]></title>
    <link href="http://candochen.github.io/blog/2014/08/29/learning-how-to-learn-1/"/>
    <updated>2014-08-29T19:25:12+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/29/learning-how-to-learn-1</id>
    <content type="html"><![CDATA[<p>Learning How to Learn 是我在Coursera上的一门由UC San Diego的Dr. Terrence Sejnowski, Dr. Barbara Oakley 主讲的课（你如果也喜欢这么课的话，请到www.coursera.org 搜Learning How to Learn），它是主要讲如何学习的。上了两周之后，我觉得这门课非常有用，甚至对我以后的人生都有用，所以我要把一些内容做下记录。</p>

<h1 id="procrastination">Procrastination拖延症</h1>

<p>每个人都有或多或少都有拖延症，但是有些人严重些。当你要解决一个你不喜欢的问题时，比如做数学题， 这时候你大脑中关于痛苦的区域就会被激活，与此同时，你的大脑自然而然地会激活另外一个功能–寻找舒适，于是你的大脑把注意力转向让你感到舒服的事情中去，比如做简单的事情，或者上网聊天，这似乎让你感到些快乐，但是别忘了这快乐是短暂的。所以，当你遇到困难任务是，你的大脑是这样反应的:
Unhappy felling -&gt;You funnel attention onto a more pleasant task -&gt; Feel happy(temporarily)</p>

<p>如何解决这个问题呢？我们可以借助一个工具，Pomodoro （番茄工作法），具体做法是：</p>

<blockquote>
  <ol>
    <li>25 minutes</li>
    <li>no interruptions</li>
    <li>focus</li>
    <li>reward</li>
  </ol>
</blockquote>

<p>你一定要给自己一个不受中断的25分钟，在这25分钟内你要集中精力解决问题，当问题解决完成之后别忘了给自己一个奖励，比如上网，听歌… 时间是5分钟，然后开始下个25分钟…</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[休息，休息一会]]></title>
    <link href="http://candochen.github.io/blog/2014/08/27/have-a-rest/"/>
    <updated>2014-08-27T11:15:47+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/27/have-a-rest</id>
    <content type="html"><![CDATA[<p>最近工作之余，我还学习和很多其他东西，由于用力过猛，加上对知识的消化、吸收工作没有做好，导致现在感觉到身体上的疲惫和心理上的焦虑。</p>

<p>所以，我要休息，休息一会！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文昌人常说的英语]]></title>
    <link href="http://candochen.github.io/blog/2014/08/20/wenchangeenglish/"/>
    <updated>2014-08-20T19:03:03+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/20/wenchangeenglish</id>
    <content type="html"><![CDATA[<p>排球自从被华侨引进后就成了我们文昌的最热门运动，球出界的时候球员都大喊”奥赛”，它是个英语outside.   在文昌话中，螺丝刀叫”斯哥杜”, 其来源于英语”screw”.  另外我们文昌人管穿皮鞋叫穿”boots”.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些励志的话]]></title>
    <link href="http://candochen.github.io/blog/2014/08/19/inspiration/"/>
    <updated>2014-08-19T17:15:38+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/19/inspiration</id>
    <content type="html"><![CDATA[<p>尽管并不是绝对，但确实大多数事情都需要熟能生巧。做得多了，自然就擅长了；擅长了，就自然做得比别人好；做得比别人好，兴趣就大起来了，而后就更喜欢做，更擅长，更……良性循环。
但，同样，做得多就需要大量的时间投入。没兴趣，往往只不过是结果而已，却被当作不去做好的理由，最终的惩罚就是大量的时间白白流逝。
往往并不是有兴趣才能做好，而是做好了才有兴趣。
方法固然重要，但是比起“用功”来说，方法几乎可以忽略不计。所有学习上的成功，都只靠两件事：策略和坚持，而坚持本身就应该是最重要的策略。</p>

<p>事实上，没有什么要比发现、培养、呵护、调整自己的心智更重要的事情了。</p>

<p>–摘自《把时间当做朋友》</p>

<p>在你的人生中会出生很多岔道，然后呢你每一次选择就会耗去你的时间，耗去你的精力，我觉得要克服焦虑的办法，其实大概就是说你在二十岁到三十岁之间的，这一段时间的时候，在你生命力最旺盛的时候，你要想清楚几件事，第一件事你要想清楚说我这辈子最喜欢的工作是什么，就我热爱什么东西，这个是最关键的事情；第二要让自己成为一个专业的人；第三你愿意用未来的二十年时间去完成，这件你喜欢的工作和你专业的事情。</p>

<p>–摘自 《我懂你的焦虑》 吴晓波在《开讲啦》节目中的演讲</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cannot vs Can Not]]></title>
    <link href="http://candochen.github.io/blog/2014/08/18/cannot-vs-can-not/"/>
    <updated>2014-08-18T19:09:22+08:00</updated>
    <id>http://candochen.github.io/blog/2014/08/18/cannot-vs-can-not</id>
    <content type="html"><![CDATA[<p>刚才看邮件时候突然想起我平时老是分不清e.g. 和 i.e. 这两个缩写，所以特地网上查了一下。原来e.g. 是拉丁语exampli gratia 的缩写，意思是for example; 而i.e. 是拉丁语id est的缩写，意思是that is. </p>

<p>再者，我在有些邮件中看到有人写e.g.后面没有跟逗号 , 这就像for example不加逗号，这也是不对的。至于我们平常工作中用到的cannot, 比如This bug cannot be reproduced. 一般来说，我们不用can not. 看网上解释，两种用法都对，但是第一种比较常用，假如你想用can not，下面这两种情况可能符合： </p>

<ul>
  <li>
    <p>和别的词一起用，比如can not only</p>
  </li>
  <li>
    <p>表示强调，比如 No, you can not wash the dog in the Maytag.  </p>
  </li>
</ul>

<p>讲到这里，我又突然想起了，有次我开会时候的窘迫。有人跟客户电话会议，在我介绍完自己之后，老外突然来了句How are you? 我当时就懵了，心想，这时不是应该说Nice to meet you了吗？ 于是，我条件反射地说了, I am fine, and you. 于是客套来客套来，客套去。</p>

<p>有个老外程序员说，你们中国人真有趣，我说How are you的时候，你们一定会说Fine, and you，就好像一个数学函数一样。</p>

<p>但是，我们真的不知道怎么说了呀，老师又没教，也没有专门培训过。所以，跟不同的客户电话会议之前，我老是神经紧张，生怕说错了什么话，导致让对方觉得我不够礼貌。幸好说native english的老外们一般都比较nice，有时候会很开心地跟你聊，感觉就像是一个外国人说普通话，说错了我们也觉得没什么。</p>

<p>呵呵。</p>

<p>参考链接</p>

<p><a href="http://public.wsu.edu/~brians/errors/e.g.html">http://public.wsu.edu/~brians/errors/e.g.html</a></p>

<p><a href="http://www.oxforddictionaries.com/words/cannot-or-can-not">http://www.oxforddictionaries.com/words/cannot-or-can-not</a></p>
]]></content>
  </entry>
  
</feed>
